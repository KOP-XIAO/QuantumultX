/** 
â˜‘ï¸ èµ„æºè§£æå™¨ Â©ğ’ğ¡ğšğ°ğ§  âŸ¦2020-07-17 10:59âŸ§
----------------------------------------------------------
ğŸ›  å‘ç° ğğ”ğ† è¯·åé¦ˆ: @Shawn_KOP_bot
â›³ï¸ å…³æ³¨ ğŸ†ƒğŸ…¶ ç›¸å…³é¢‘é“: https://t.me/QuanX_API
ğŸ—£ ğŸ†ƒğŸ„·ğŸ„°ğŸ„½ğŸ„ºğŸ…‚ ğŸ†ƒğŸ„¾  @Jamie CHIEN, @M**F**, @c0lada, @Peng-YM

ğŸ¤– ä¸»è¦åŠŸèƒ½: 
â¶ å°†å„æ ¼å¼çš„æœåŠ¡å™¨è®¢é˜…è§£ææˆ ğğ®ğšğ§ğ­ğ®ğ¦ğ®ğ¥ğ­ ğ— æ ¼å¼
â˜‘ï¸ æ”¯æŒ ğ—©ğ—ºğ—²ğ˜€ğ˜€/ğ—¦ğ—¦(ğ—¥/ğ——)/ğ—§ğ—¿ğ—¼ğ—·ğ—®ğ—»/ğ—¤ğ˜‚ğ—®ğ—»ğ˜ğ˜‚ğ—ºğ˜‚ğ—¹ğ˜(ğ—«)/ğ—¦ğ˜‚ğ—¿ğ—´ğ—²/ğ—›ğ—§ğ—§ğ—£(ğ—¦)
â˜‘ï¸ æä¾›è¯´æ˜ 1âƒ£ï¸ ä¸­çš„å¯é€‰ä¸ªæ€§åŒ–å‚æ•°(ç­›é€‰ã€é‡å‘½å ç­‰)
â· ğ—¿ğ—²ğ˜„ğ—¿ğ—¶ğ˜ğ—²(é‡å†™) & ğ—³ğ—¶ğ—¹ğ˜ğ—²ğ—¿(åˆ†æµ) çš„ è½¬æ¢&ç­›é€‰ 
â˜‘ï¸ ç”¨äºç¦ç”¨è¿œç¨‹å¼•ç”¨ä¸­æŸ(å‡ )é¡¹ ğ—¿ğ—²ğ˜„ğ—¿ğ—¶ğ˜ğ—²/ğ—µğ—¼ğ˜€ğ˜ğ—»ğ—®ğ—ºğ—²/ğ—³ğ—¶ğ—¹ğ˜ğ—²ğ—¿
â˜‘ï¸ ğ’ğ®ğ«ğ ğ ç±»å‹è§„åˆ™ ğ—¹ğ—¶ğ˜€ğ˜ ä¸ æ¨¡å— ğ¦ğ¨ğğ®ğ¥ğ çš„è§£æä½¿ç”¨
----------------------------------------------------------
0ï¸âƒ£ âŸ¦åŸå§‹é“¾æ¥âŸ§ ååŠ  "#" ä½¿ç”¨, ä¸åŒå‚æ•°ç”¨ "&" è¿æ¥: 
âš ï¸ â˜ ğ¡ğ­ğ­ğ©ğ¬://ğ¦ğ²ğ¬ğ®ğ›.ğœğ¨ğ¦#ğ™šğ™¢ğ™¤ğ™Ÿğ™=1&ğ™©ğ™›ğ™¤=1&ğ™ğ™£=é¦™æ¸¯+å°æ¹¾
â– æœ¬åœ°èµ„æºç‰‡æ®µå¼•ç”¨, è¯·å°†å‚æ•° "#ğ—¶ğ—»=ğ˜…ğ˜…ğ˜…." å¡«å…¥æ–‡ä»¶ç¬¬ â‘  è¡Œ â–

1ï¸âƒ£ âŸ¦ğ¬ğğ«ğ¯ğğ« èŠ‚ç‚¹âŸ§ â  å‚æ•°è¯´æ˜:
â¦¿ ğ—¶ğ—»ğ—³ğ—¼=1, å¼€å¯é€šçŸ¥æç¤ºæœºåœº âœˆï¸ æµé‡ä¿¡æ¯(å¦‚æœ‰æä¾›);
â¦¿ ğ—²ğ—ºğ—¼ğ—·ğ—¶=1(å›½è¡Œè®¾å¤‡ç”¨2)/-1, æ·»åŠ /åˆ é™¤èŠ‚ç‚¹åå†…åœ°åŒºæ——å¸œ;
â¦¿ ğ˜‚ğ—±ğ—½=1, ğ˜ğ—³ğ—¼=1, ğ˜ğ—¹ğ˜€13=1, åˆ†åˆ«å¼€å¯ ğ®ğğ©-ğ«ğğ¥ğšğ²/ğŸğšğ¬ğ­-ğ¨ğ©ğğ§/ğ­ğ¥ğ¬1.3;
â¦¿ ğ—°ğ—²ğ—¿ğ˜=0, å¼ºåˆ¶"ğ­ğ¥ğ¬-ğ¯ğğ«ğ¢ğŸğ¢ğœğšğ­ğ¢ğ¨ğ§=ğŸğšğ¥ğ¬ğ" è·³è¿‡è¯ä¹¦éªŒè¯;
â¦¿ ğ—¶ğ—», ğ—¼ğ˜‚ğ˜, åˆ†åˆ«ä¸º ä¿ç•™/åˆ é™¤ èŠ‚ç‚¹;
    â– å¤šå‚æ•°(é€»è¾‘"æˆ–")ç”¨ "+", é€»è¾‘"ä¸"ç”¨ "." è¡¨ç¤º;
    â– æ”¯æŒä¸­æ–‡, æ“ä½œä»¥ä¸‹ç‰¹æ®Šå­—ç¬¦æ—¶è¯·å…ˆæ›¿æ¢
        âˆ "+"â‡’"%2B", ç©ºæ ¼â‡’"%20", "&"â‡’"%26", "."â‡’"\."
    â– ç¤ºèŒƒ: "ğ¢ğ§=é¦™æ¸¯.0\.2å€ç‡+å°æ¹¾&ğ¨ğ®ğ­=é¦™æ¸¯%20ğğ†ğ"
â¦¿ ğ—¿ğ—²ğ—´ğ—²ğ˜…, æ­£åˆ™ç­›é€‰, è¯·è‡ªè¡ŒæŠ˜è…¾æ­£åˆ™è¡¨è¾¾å¼;
    â– å¯ä¸ ğ—¶ğ—»/ğ—¼ğ˜‚ğ˜ å‚æ•°æ­é…ä½¿ç”¨ï¼Œğ—¶ğ—»/ğ—¼ğ˜‚ğ˜ ä¼šä¼˜å…ˆæ‰§è¡Œ;
    â– å¯¹èŠ‚ç‚¹çš„å®Œæ•´ä¿¡æ¯è¿›è¡ŒåŒ¹é…(ç±»å‹ã€ç«¯å£ã€åŠ å¯†ç­‰)
â¦¿ ğ—¿ğ—²ğ—»ğ—®ğ—ºğ—², é‡å‘½å: "æ—§å@æ–°å", "å‰ç¼€@", "@åç¼€", ç”¨ "+" è¿æ¥å¤šä¸ªå‚æ•°;
    â– æ”¯æŒä¸­æ–‡, æ“ä½œä»¥ä¸‹ç‰¹æ®Šå­—ç¬¦æ—¶è¯·å…ˆæ›¿æ¢
        âˆ "@"â‡’"%40","+"â‡’"%2B", ç©ºæ ¼â‡’"%20", "&"â‡’"%26"
    â– åˆ é™¤å­—æ®µ: "å­—æ®µ1.å­—æ®µ2â˜ ï¸", æƒ³åˆ é™¤ "." æ—¶ç”¨ "\." æ›¿ä»£
    â– ç¤ºèŒƒ: "ğ«ğğ§ğšğ¦ğ=é¦™æ¸¯@ğ‡ğŠ+[ğ’ğ’]@+@[1ğ—]+æµé‡.0\.2â˜ ï¸"
â¦¿ ğ—±ğ—²ğ—¹ğ—¿ğ—²ğ—´, åˆ©ç”¨æ­£åˆ™å‚æ•°æ¥åˆ é™¤èŠ‚ç‚¹åä¸­çš„å­—æ®µ(âš ï¸ æ…ç”¨)
â¦¿ ğ˜€ğ—¼ğ—¿ğ˜=1, -1, x,åˆ†åˆ«æ ¹æ®èŠ‚ç‚¹å æ­£åº/é€†åº/éšæœº æ’åº
â¦¿ ğ—¿ğ—²ğ—½ğ—¹ğ—®ğ—°ğ—² å‚æ•°, æ­£åˆ™æ›¿æ¢ ğ¬ğğ«ğ¯ğğ« ä¸­å†…å®¹, å¯ç”¨äºé‡å‘½å/æ›´æ”¹åŠ å¯†æ–¹å¼ç­‰
â¦¿ ğ˜€ğ—³ğ—¶ğ—¹ğ˜ğ—²ğ—¿ å‚æ•°å¯ä»¥ä¼ å…¥ä¸€æ®µ base64 ç¼–ç çš„è„šæœ¬ï¼Œç”¨äºè¿‡æ»¤è®¢é˜…èŠ‚ç‚¹
â¦¿ ğ˜€ğ—¿ğ—²ğ—»ğ—®ğ—ºğ—² å‚æ•°å¯ä»¥ä¼ å…¥ä¸€æ®µ base64 ç¼–ç çš„è„šæœ¬ï¼Œç”¨äºé‡å‘½åè®¢é˜…èŠ‚ç‚¹
    â– å…·ä½“å‚è§æ­¤è¯´æ˜: 
        âˆ https://github.com/KOP-XIAO/QuantumultX/pull/9


2âƒ£ï¸ âŸ¦ğ«ğğ°ğ«ğ¢ğ­ğ é‡å†™âŸ§/âŸ¦ğŸğ¢ğ¥ğ­ğğ« åˆ†æµâŸ§ â  å‚æ•°è¯´æ˜:
â¦¿ ğ—¶ğ—», ğ—¼ğ˜‚ğ˜, æ ¹æ®å…³é”®è¯ ä¿ç•™/ç¦ç”¨ ç›¸å…³çš„è§„åˆ™ã€é‡å†™;
â¦¿ ğ—¶ğ—»ğ—µğ—», ğ—¼ğ˜‚ğ˜ğ—µğ—», â€œä¿ç•™/åˆ é™¤â€ä¸»æœºå(ğ’‰ğ’ğ’”ğ’•ğ’ğ’‚ğ’ğ’†);
    â– ç¤ºèŒƒ: ç¦ç”¨ "æ·˜å®æ¯”ä»·" åŠ "weibo" çš„ js åŒä¸»æœºå
 ğ¡ğ­ğ­ğ©ğ¬://ğ¦ğ²ğ¥ğ¢ğ¬ğ­#ğ’ğ’–ğ’•=ğ’•ğ’ƒ_ğ’‘ğ’“ğ’Šğ’„ğ’†.ğ’‹ğ’”+ğ’˜ğ’ƒ_ğ’‚ğ’….ğ’‹ğ’”&ğ’ğ’–ğ’•ğ’‰ğ’=ğ’˜ğ’†ğ’Šğ’ƒğ’
â¦¿ ğ—±ğ˜€ğ˜=ğ—¿ğ—²ğ—´ğ—²ğ˜…/ğ˜€ğ—°ğ—¿ğ—¶ğ—½ğ˜ï¼Œåˆ†åˆ«ä¸ºåªä¿ç•™ ğ’ğ®ğ«ğ ğ-ğ¦ğ¨ğğ®ğ¥ğ ä¸­çš„ ğ®ğ«ğ¥-ğ«ğğ ğğ±/ğ¬ğœğ«ğ¢ğ©ğ­(302/307), é»˜è®¤å…¨éƒ¨ä¿ç•™;
    â– æŠŠå« ğ®ğ«ğ¥-ğ«ğğ ğğ± çš„ ğ—¿ğ˜‚ğ—¹ğ—²-ğ˜€ğ—²ğ˜ è½¬æˆé‡å†™æ—¶, ä¸€å®šè¦ ğ—±ğ˜€ğ˜=ğ—¿ğ—²ğ—´ğ—²ğ˜…
â¦¿ ğ—½ğ—¼ğ—¹ğ—¶ğ—°ğ˜† å‚æ•°, ç”¨äºç›´æ¥æŒ‡å®šç­–ç•¥ç»„ï¼Œæˆ–ä¸º ğ’ğ®ğ«ğ ğ ç±»å‹ ğ—¿ğ˜‚ğ—¹ğ—²-ğ˜€ğ—²ğ˜ ç”Ÿæˆç­–ç•¥ç»„(é»˜è®¤"ğ’ğ¡ğšğ°ğ§"ç­–ç•¥ç»„);
â¦¿ ğ—¿ğ—²ğ—½ğ—¹ğ—®ğ—°ğ—² å‚æ•°, æ­£åˆ™æ›¿æ¢ ğŸğ¢ğ¥ğ­ğğ«/ğ«ğğ°ğ«ğ¢ğ­ğ å†…å®¹, regex@new-parameter;
    â– å°†æ·˜å®æ¯”ä»·ä¸­è„šæœ¬æ›¿æ¢æˆ lite ç‰ˆæœ¬, tiktok ä¸­ JP æ¢æˆ KR
		âˆ ğ«ğğ©ğ¥ğšğœğ=(ğ©ğ«ğ¢ğœğ)(.*)@$1_ğ¥ğ¢ğ­ğ$2+ğ£ğ©@ğ¤ğ« 

3âƒ£ï¸ é€šçŸ¥å‚æ•° ğ—»ğ˜ğ—³=0/1, ç”¨äº å…³é—­/æ‰“å¼€ èµ„æºè§£æå™¨çš„æç¤ºé€šçŸ¥
â¦¿ ğ—¿ğ—²ğ˜„ğ—¿ğ—¶ğ˜ğ—²/ğ—³ğ—¶ğ—¹ğ˜ğ—²ğ—¿ é»˜è®¤â€œå¼€å¯â€é€šçŸ¥æç¤º, ä»¥é˜²è§„åˆ™è¯¯åˆ é™¤
â¦¿ ğ˜€ğ—²ğ—¿ğ˜ƒğ—²ğ—¿ èµ„æºè§£æåˆ™é»˜è®¤â€å…³é—­â€œé€šçŸ¥æç¤º
----------------------------------------------------------
 */


/**
 * ä½¿ç”¨è¯´æ˜ï¼Œ
0ï¸âƒ£ åœ¨QuantumultX é…ç½®æ–‡ä»¶ä¸­[general] éƒ¨åˆ†ï¼ŒåŠ å…¥ resource_parser_url=https://raw.githubusercontent.com/KOP-XIAO/QuantumultX/master/Scripts/resource-parser.js
âš ï¸âš ï¸å¦‚æç¤º"æ²¡æœ‰è‡ªå®šä¹‰è§£æå™¨"ï¼Œè¯·é•¿æŒ‰å³ä¸‹è§’å›¾æ ‡åç‚¹å‡»å·¦ä¾§åˆ·æ–°æŒ‰é’®ï¼Œæ›´æ–°èµ„æºï¼Œåå°é€€å‡º appï¼Œç›´åˆ°å‡ºç°è§£æå™¨è¯´æ˜
1ï¸âƒ£ å‡è®¾åŸå§‹è®¢é˜…è¿æ¥ä¸º: https://raw.githubusercontent.com/crossutility/Quantumult-X/master/server-complete.txt , 
2ï¸âƒ£ å‡è®¾ä½ æƒ³è¦ä¿ç•™çš„å‚æ•°ä¸º in=tls+ss, æƒ³è¦è¿‡æ»¤çš„å‚æ•°ä¸º out=http+2, è¯·æ³¨æ„ä¸‹é¢è®¢é˜…é“¾æ¥åä¸€å®šè¦åŠ  â€#â€œ ç¬¦å·
3ï¸âƒ£ åˆ™å¡«å…¥ Quanx èŠ‚ç‚¹å¼•ç”¨çš„çš„æ€»é“¾æ¥ä¸º  https://raw.githubusercontent.com/crossutility/Quantumult-X/master/server-complete.txt#in=tls+ss&out=http+2
4ï¸âƒ£ å¡«å…¥ä¸Šè¿°é“¾æ¥, å¹¶æ‰“å¼€çš„èµ„æºè§£æå™¨å¼€å…³

PS. éšè—å‚æ•° ntf=0/1, ç”¨äºå…³é—­/æ‰“å¼€èµ„æºè§£æå™¨çš„æç¤ºé€šçŸ¥
â¦¿ rewrite/filter èµ„æºåœ¨æœ‰ in/out å‚æ•°æ—¶ä¼šé»˜è®¤å¼€å¯é€šçŸ¥æç¤º, ä»¥é˜²è§„åˆ™è¯¯åˆ é™¤

------------------------------
 */

var content0 = $resource.content;
var link0 = $resource.link;
//debug
//const $resource={}
//const $done=function(snt){return snt}
//parameters
var para = (link0.indexOf("http") != -1 && link0.indexOf("://") != -1) ? link0 : link0 + content0.split("\n")[0];
var para1 = para.slice(para.indexOf("#") + 1) //é˜²æ­¢å‚æ•°ä¸­å…¶å®ƒä½ç½®ä¹Ÿå­˜åœ¨"#"
var mark0 = para.indexOf("#") != -1 ? true : false;
const subinfo = $resource.info;
const subtag = $resource.tag != undefined ? $resource.tag : "";
var Pinfo = mark0 && para1.indexOf("info=") != -1 ? para1.split("info=")[1].split("&")[0] : 0;
var ntf_flow = 0;
//å¸¸ç”¨é‡
const Base64 = new Base64Code();
const escapeRegExp = str => str.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&'); //å¤„ç†ç‰¹æ®Šç¬¦å·ä»¥ä¾¿æ­£åˆ™åŒ¹é…ä½¿ç”¨
var link1 = link0.split("#")[0]
const qxpng = "https://raw.githubusercontent.com/crossutility/Quantumult-X/master/quantumult-x.png" // server sub-info link
const subinfo_link = { "open-url": "https://t.me/QuanX_API", "media-url": "https://shrtm.nu/ebAr" };
const subinfo_link1 = { "open-url": link1, "media-url": "https://shrtm.nu/uo13" } // server sub-info link(fake-nodes)
const rwrite_link = { "open-url": link1, "media-url": "https://shrtm.nu/x3o2" } // rewrite filter link
const rwhost_link = { "open-url": link1, "media-url": "https://shrtm.nu/0n5J" } // hostname filter link
const rule_link = { "open-url": link1, "media-url": "https://shrtm.nu/cpHD" } // rule filter link
const nan_link = { "open-url": link1, "media-url": qxpng } // nan error link
const bug_link = { "open-url": "https://t.me/Shawn_KOP_bot", "media-url": "https://shrtm.nu/obcB" } // bug link
const sub_link = { "open-url": link1, "media-url": "https://shrtm.nu/ebAr" } // server link


SubFlow() //æµé‡é€šçŸ¥
var type0 = Type_Check(content0); //  ç±»å‹
var Pin0 = mark0 && para1.indexOf("in=") != -1 ? (para1.split("in=")[1].split("&")[0].split("+")).map(decodeURIComponent) : null;
var Pout0 = mark0 && para1.indexOf("out=") != -1 ? (para1.split("out=")[1].split("&")[0].split("+")).map(decodeURIComponent) : null;
var Psfilter = mark0 && para1.indexOf("sfilter=") != -1 ? Base64.decode(para1.split("sfilter=")[1].split("&")[0]) : null; // script filter
var Preg = mark0 && para1.indexOf("regex=") != -1 ? decodeURIComponent(para1.split("regex=")[1].split("&")[0]) : null; //serveræ­£åˆ™è¿‡æ»¤å‚æ•°
var Pregdel = mark0 && para1.indexOf("delreg=") != -1 ? decodeURIComponent(para1.split("delreg=")[1].split("&")[0]) : null; // æ­£åˆ™åˆ é™¤å‚æ•°
var Phin0 = mark0 && para1.indexOf("inhn=") != -1 ? (para1.split("inhn=")[1].split("&")[0].split("+")).map(decodeURIComponent) : null; //hostname 
var Phout0 = mark0 && para1.indexOf("outhn=") != -1 ? (para1.split("outhn=")[1].split("&")[0].split("+")).map(decodeURIComponent) : null; //hostname
var Preplace = mark0 && para1.indexOf("replace=") != -1 ? decodeURIComponent(para1.split("replace=")[1].split("&")[0]) : null; //filter/rewrite æ­£åˆ™æ›¿æ¢
var Pemoji = mark0 && para1.indexOf("emoji=") != -1 ? para1.split("emoji=")[1].split("&")[0] : null;
var Pudp0 = mark0 && para1.indexOf("udp=") != -1 ? para1.split("udp=")[1].split("&")[0] : 0;
var Ptfo0 = mark0 && para1.indexOf("tfo=") != -1 ? para1.split("tfo=")[1].split("&")[0] : 0;
var Prname = mark0 && para1.indexOf("rename=") != -1 ? para1.split("rename=")[1].split("&")[0].split("+") : null;
var Psrename = mark0 && para1.indexOf("srename=") != -1 ? Base64.decode(para1.split("srename=")[1].split("&")[0]) : null; // script rename
var Prrname = mark0 && para1.indexOf("rrname=") != -1 ? para1.split("rrname=")[1].split("&")[0].split("+") : null;
var Ppolicy = mark0 && para1.indexOf("policy=") != -1 ? decodeURIComponent(para1.split("policy=")[1].split("&")[0]) : "Shawn";
var Pcert0 = mark0 && para1.indexOf("cert=") != -1 ? para1.split("cert=")[1].split("&")[0] : 1;
var Psort0 = mark0 && para1.indexOf("sort=") != -1 ? para1.split("sort=")[1].split("&")[0] : 0;
var PTls13 = mark0 && para1.indexOf("tls13=") != -1 ? para1.split("tls13=")[1].split("&")[0] : 0;
var Pntf0 = mark0 && para1.indexOf("ntf=") != -1 ? para1.split("ntf=")[1].split("&")[0] : 2;
var Pb64 = mark0 && para1.indexOf("b64=") != -1 ? para1.split("b64=")[1].split("&")[0] : 0;
var emojino = [" 0ï¸âƒ£ ", " 1âƒ£ï¸ ", " 2âƒ£ï¸ ", " 3âƒ£ï¸ ", " 4âƒ£ï¸ ", " 5âƒ£ï¸ ", " 6âƒ£ï¸ ", " 7âƒ£ï¸ ", " 8âƒ£ï¸ ", " 9âƒ£ï¸ ", " ğŸ”Ÿ "]
var pfi = Pin0 ? "in=" + Pin0.join(", ") + ",  " : ""
var pfo = Pout0 ? "out=" + Pout0.join(", ") : ""
var pfihn = Phin0 ? "inhn=" + Phin0.join(", ") + ",  " : ""
var pfohn = Phout0 ? "outhn=" + Phout0.join(", ") : ""
var flow = "";
var exptime = "";
//$notify(type0)

//å“åº”å¤´æµé‡å¤„ç†éƒ¨åˆ†
function SubFlow() {
    if (Pinfo == 1 && subinfo) {
        var sinfo = subinfo.replace(/ /g, "").toLowerCase();
        var total = "æ€»æµé‡: " + (parseFloat(sinfo.split("total=")[1].split(",")[0]) / (1024 ** 3)).toFixed(2) + "GB";
        var usd = "å·²ç”¨æµé‡: " + ((parseFloat(sinfo.split("upload=")[1].split(",")[0]) + parseFloat(sinfo.split("download=")[1].split(",")[0])) / (1024 ** 3)).toFixed(2) + "GB"
        var left = "å‰©ä½™æµé‡: " + ((parseFloat(sinfo.split("total=")[1].split(",")[0]) / (1024 ** 3)) - ((parseFloat(sinfo.split("upload=")[1].split(",")[0]) + parseFloat(sinfo.split("download=")[1].split(",")[0])) / (1024 ** 3))).toFixed(2) + "GB"
        if (sinfo.indexOf("expire=") != -1) {
            var epr = new Date(parseFloat(sinfo.split("expire=")[1].split(",")[0]) * 1000);
            var year = epr.getFullYear();  // è·å–å®Œæ•´çš„å¹´ä»½(4ä½,1970)
            var mth = epr.getMonth() + 1 < 10 ? '0' + (epr.getMonth() + 1) : (epr.getMonth() + 1);  // è·å–æœˆä»½(0-11,0ä»£è¡¨1æœˆ,ç”¨çš„æ—¶å€™è®°å¾—åŠ ä¸Š1)
            var day = epr.getDate() < 10 ? "0" + (epr.getDate()) : epr.getDate();
            epr = "è¿‡æœŸæ—¶é—´: " + year + "-" + mth + "-" + day
        } else {
            epr = ""; //"è¿‡æœŸæ—¶é—´: âœˆï¸ æœªæä¾›è©²ä¿¡æ¯" //æ²¡è¿‡æœŸæ—¶é—´çš„æ˜¾ç¤ºè®¢é˜…é“¾æ¥
        }
        var message = total + "\n" + usd + ", " + left;
        ntf_flow = 1;
        $notify("æµé‡ä¿¡æ¯: âŸ¦" + subtag + "âŸ§", epr, message, subinfo_link)
    }
}

//flag=1,2,3åˆ†åˆ«ä¸º serverã€rewriteã€rule ç±»å‹
if (type0 == "Subs-B64Encode") {
    total = SubsEd2QX(content0, Pudp0, Ptfo0, Pcert0, PTls13);
    flag = 1;
} else if (type0 == "Subs") {
    total = Subs2QX(content0, Pudp0, Ptfo0, Pcert0, PTls13);
    flag = 1;
} else if (type0 == "QuanX") {
    total = isQuanX(content0);
    flag = 1;
} else if (type0 == "Surge") {
    total = Surge2QX(content0);
    flag = 1;
} else if (type0 == "sgmodule") {
    flag = 2
    if (para1.indexOf("dst=regex") != -1) {
        total = URX2QX(content0)
    } else if (para1.indexOf("dst=script") != -1) {
        total = SCP2QX(content0)
    } else {
        total = SGMD2QX(content0)
    }
    total = Rewrite_Filter(total, Pin0, Pout0);
} else if (type0 == "rewrite") {
    flag = 2;
    content0 = content0.split("\n");
    total = Rewrite_Filter(content0, Pin0, Pout0);
} else if (type0 == "Rule") {
    flag = 3;
    total = content0.split("\n");
    total = Rule_Handle(total, Pout0, Pin0);
} else if (content0.trim() == "") {
    $notify("â€¼ï¸ å¼•ç”¨" + "âŸ¦" + subtag + "âŸ§" + " è¿”å›å…§å®¹ä¸ºç©º", "â‰ï¸ ç‚¹é€šçŸ¥è·³è½¬ä»¥ç¡®è®¤é“¾æ¥æ˜¯å¦å¤±æ•ˆ", para.split("#")[0], nan_link);
    flag = 0;
    $done({ content: "" })
} else if (type0 == "unknown") {
    $notify("ğŸ˜­ æœªèƒ½è§£æ, å¯èƒ½æ˜¯ bug â‰ï¸  " + "âŸ¦" + subtag + "âŸ§", "ğŸ‘» æœ¬è§£æå™¨ æš‚æœªæ”¯æŒ/æœªèƒ½è¯†åˆ« è¯¥è®¢é˜…æ ¼å¼", "âš ï¸ å°†ç›´æ¥å¯¼å…¥Quantumult X \n å¦‚è®¤ä¸ºæ˜¯ BUG, è¯·ç‚¹é€šçŸ¥è·³è½¬åé¦ˆ", bug_link);
    $done({ content: content0 });
    flag = -1;
} else { flag = 0 }

if (flag == 3) { // rule ç±»å‹
    $done({ content: total.join("\n") });
} else if (flag == 2) { // rewrite ç±»å‹
    if (Preplace) { total = ReplaceReg(total, Preplace) }
    $done({ content: total.join("\n") });
} else if (flag == 1) { //server ç±»å‹
    if (Pinfo == 1 && ntf_flow == 0) { //å‡èŠ‚ç‚¹ç±»å‹çš„æµé‡é€šçŸ¥
        flowcheck(total)
    }
    if (Pin0 || Pout0) { total = Filter(total, Pin0, Pout0) }
    if (Preg) { total = total.map(Regex).filter(Boolean) }
    if (Psfilter) { total = FilterScript(total, Psfilter) }
    if (Prrname) {
        var Prn = Prrname;
        total = total.map(Rename);
    }
    if (Pemoji) { total = emoji_handle(total, Pemoji); }
    if (Prname) {
        var Prn = Prname;
        total = total.map(Rename);
    }
    if (Pregdel) {
        var delreg = Pregdel
        total = total.map(DelReg)
    }
    if (Preplace) { // server ç±»å‹ä¹Ÿå¯ç”¨ replace å‚æ•°è¿›è¡Œé‡å‘½åæ“ä½œ
        total = ReplaceReg(total, Preplace)
    }
    if (Psrename) { total = RenameScript(total, Psrename) }
    if (Psort0 == 1 || Psort0 == -1) {
        total = QXSort(total, Psort0);
    } else if (Psort0 == "x") {
        total = shuffle(total)
    }
    total = TagCheck_QX(total)
    total = total.join("\n");
    //$notify("Final","test",total)
    if (flag == 1) { total = Base64.encode(total) } //å¼ºåˆ¶èŠ‚ç‚¹ç±»å‹çš„ base64
    $done({ content: total });
}

//flowcheck-fake-server
function flowcheck(cnt) {
    for (var i = 0; i < cnt.length; i++) {
        var item = cnt[i];
        var nl = item.slice(item.indexOf("tag"))
        var nm = nl.slice(nl.indexOf("=") + 1)
        if (item.indexOf("å‰©ä½™æµé‡") != -1) {
            flow = nm
        } else if (item.indexOf("è¿‡æœŸæ—¶é—´") != -1) {
            exptime = nm
        }
    }
    if (flow != "") { $notify("æµé‡ä¿¡æ¯: âŸ¦" + subtag + "âŸ§", flow, exptime, subinfo_link1) }
}

// éšæœºæ´—ç‰Œæ’åº
function shuffle(arr) {
    var input = arr;
    for (var i = input.length - 1; i >= 0; i--) {
        var randomIndex = Math.floor(Math.random() * (i + 1));
        var itemAtIndex = input[randomIndex];
        input[randomIndex] = input[i];
        input[i] = itemAtIndex;
    }
    return input;
}

//åˆ¤æ–­è®¢é˜…ç±»å‹
function Type_Check(subs) {
    var type = "unknown"
    var RuleK = ["host", "domain", "ip-cidr", "geoip", "user-agent", "ip6-cidr"];
    var QuanXK = ["shadowsocks=", "trojan=", "vmess=", "http="];
    var SurgeK = ["=ss,", "=vmess,", "=trojan,", "=http,", "=custom,", "=https,", "=shadowsocks", "=shadowsocksr"];
    var SubK = ["dm1lc3M", "c3NyOi8v", "dHJvamFu", "c3M6Ly", "c3NkOi8v"];
    var RewriteK = [" url "]
    var SubK2 = ["ss://", "vmess://", "ssr://", "trojan://", "ssd://"];
    var html = "DOCTYPE html"
    var subi = subs.replace(/ /g, "")
    const RuleCheck = (item) => subs.toLowerCase().indexOf(item) != -1;
    const QuanXCheck = (item) => subi.toLowerCase().indexOf(item) != -1;
    const SurgeCheck = (item) => subi.toLowerCase().indexOf(item) != -1;
    const SubCheck = (item) => subs.indexOf(item) != -1;
    const RewriteCheck = (item) => subs.indexOf(item) != -1;
    var subsn = subs.split("\n")
    if (subs.indexOf(html) != -1) {
        $notify("â€¼ï¸ è¯¥é“¾æ¥è¿”å›å†…å®¹æœ‰è¯¯", "â‰ï¸ ç‚¹é€šçŸ¥è·³è½¬ä»¥ç¡®è®¤é“¾æ¥æ˜¯å¦å¤±æ•ˆ", link0, nan_link);
        type = "web";
    } else if (subsn.length >= 1 && SubK2.some(SubCheck)) { //æœªb64åŠ å¯†çš„å¤šè¡ŒURI ç»„åˆè®¢é˜…
        type = "Subs"
    } else if (SubK.some(SubCheck)) {  //b64åŠ å¯†çš„è®¢é˜…ç±»å‹
        type = "Subs-B64Encode"
    } else if (subi.indexOf("tag=") != -1 && QuanXK.some(QuanXCheck)) {
        type = "Subs" // QuanX list
    } else if (subs.indexOf("[Proxy]") != -1) {
        type = "Surge"; // Surge Profiles
    } else if (SurgeK.some(SurgeCheck)) {
        type = "Subs" // Surge proxy list
    } else if (subi.indexOf("[Script]") != -1 || subi.indexOf("[Rule]") != -1 || subi.indexOf("[URL Rewrite]") != -1 || para1.indexOf("dst=regex") != -1) { // Surge module /rule-set(url-regex) ç±»å‹
        type = "sgmodule"
    } else if (subi.indexOf("hostname=") != -1 || RewriteK.some(RewriteCheck)) {
        type = "rewrite"
    } else if (RuleK.some(RuleCheck) && subs.indexOf(html) == -1) {
        type = "Rule";
    }
    return type
}


function Trim(item) {
    return item.trim()
}

//url-regex è½¬æ¢æˆ Quantumult X
function URX2QX(subs) {
    var nrw = []
    var rw = ""
    subs = subs.split("\n")
    for (var i = 0; i < subs.length; i++) {
        if (subs[i].slice(0, 9) == "URL-REGEX") {
            rw = subs[i].replace(/ /g, "").split(",REJECT")[0].split("GEX,")[1] + " url " + "reject-200"
            nrw.push(rw)
        }
    }
    return nrw
}

//script è½¬æ¢æˆ Quantumult X
function SCP2QX(subs) {
    var nrw = []
    var rw = ""
    subs = subs.split("\n")
    for (var i = 0; i < subs.length; i++) {
        if (subs[i].slice(0, 8) == "hostname") {
            hn = subs[i].replace(/\%.*\%/g, "")
            nrw.push(hn)
        }
        var SC = ["type=", ".js", "pattern=", "script-path="]
        const sccheck = (item) => subs[i].indexOf(item) != -1
        if (SC.every(sccheck)) { // surge js æ–°æ ¼å¼
            ptn = subs[i].split("pattern=")[1].split(",")[0]
            js = subs[i].split("script-path=")[1].split(",")[0]
            type = subs[i].split("type=")[1].split(",")[0].trim()
            if (type == "http-response" && subs[i].indexOf("requires-body=1") != -1) {
                type = "script-response-body "
            } else if (type == "http-response" && subs[i].indexOf("requires-body=1") == -1) {
                type = "script-response-header "
            } else if (type == "http-request" && subs[i].indexOf("requires-body=1") != -1) {
                type = "script-request-body "
            } else if (type == "http-request" && subs[i].indexOf("requires-body=1") == -1) {
                type = "script-request-header "
            }
            rw = ptn + " url " + type + js
            nrw.push(rw)
        } else if (subs[i].indexOf(" 302") != -1 || subs[i].indexOf(" 307") != -1) { //rewrite å¤å†™
            rw = subs[i].split(" ")[0] + " url " + subs[i].split(" ")[2] + " " + subs[i].split(" ")[1]
            nrw.push(rw)
        } else if (subs[i].indexOf("script-path") != -1) { //surge js æ—§å†™æ³•
            type = subs[i].split(" ")[0]
            js = subs[i].split("script-path")[1].split("=")[1].split(",")[0]
            ptn = subs[i].split(" ")[1]
            if (type == "http-response" && subs[i].indexOf("requires-body=1") != -1) {
                type = "script-response-body "
            } else if (type == "http-response" && subs[i].indexOf("requires-body=1") == -1) {
                type = "script-response-header "
            } else if (type == "http-request" && subs[i].indexOf("requires-body=1") != -1) {
                type = "script-request-body "
            } else if (type == "http-request" && subs[i].indexOf("requires-body=1") == -1) {
                type = "script-request-header "
            }
            rw = ptn + " url " + type + js
            nrw.push(rw)
        }
    }
    return nrw
}
// å¦‚æœ URL-Regex è·Ÿ rewrite/script éƒ½éœ€è¦
function SGMD2QX(subs) {
    var nrw0 = URX2QX(subs)
    var nrw1 = SCP2QX(subs)
    var nrwt = [...nrw0, ...nrw1]
    return nrwt
}

//Rewriteè¿‡æ»¤ï¼Œä½¿ç”¨+è¿æ¥å¤šä¸ªå…³é”®è¯(é€»è¾‘"æˆ–"):in ä¸ºä¿ç•™ï¼Œout ä¸ºæ’é™¤
function Rewrite_Filter(subs, Pin, Pout) {
    var Nlist = [];
    var noteK = ["//", "#", ";"];
    var hnc = 0;
    var dwrite = []
    var hostname = ""
    for (var i = 0; i < subs.length; i++) {
        subi = subs[i].trim();
        var subii = subi.replace(/ /g, "")
        if (subi != "") {
            const notecheck = (item) => subi.indexOf(item) == 0
            if (noteK.some(notecheck)) { // æ³¨é‡Šé¡¹è·³è¿‡ 
                continue;
            } else if (hnc == 0 && subii.indexOf("hostname=") == 0) { //host name éƒ¨åˆ†
                hostname = (Phin0 || Phout0) ? HostNamecheck(subi, Phin0, Phout0) : subi;//hostname éƒ¨åˆ†
            } else if (subii.indexOf("hostname=") != 0) { //rewrite éƒ¨åˆ†
                var inflag = Rcheck(subi, Pin);
                var outflag = Rcheck(subi, Pout);
                if (outflag == 1 || inflag == 0) {
                    dwrite.push(subi); //out å‘½ä¸­
                } else if (outflag == 0 && inflag != 0) { //out æœªå‘½ä¸­ && in æœªæ’é™¤
                    Nlist.push(subi);
                } else if (outflag == 2 && inflag != 0) { //æ—  out å‚æ•° && in æœªæ’é™¤
                    Nlist.push(subi);
                }
            }
        }
    }
    if (Pntf0 != 0) {
        nowrite = dwrite.length <= 10 ? emojino[dwrite.length] : dwrite.length
        no1write = Nlist.length <= 10 ? emojino[Nlist.length] : Nlist.length
        if (Pin0 && no1write != " 0ï¸âƒ£ ") { //æœ‰ in å‚æ•°å°±é€šçŸ¥ä¿ç•™é¡¹ç›®
            $notify("ğŸ¤– " + "é‡å†™å¼•ç”¨  âŸ " + "âŸ¦" + subtag + "âŸ§", "â›”ï¸ ç­›é€‰å‚æ•°: " + pfi + pfo, "â˜ ï¸ é‡å†™ rewrite ä¸­ä¿ç•™ä»¥ä¸‹" + no1write + "ä¸ªåŒ¹é…é¡¹:" + "\n â¨· " + Nlist.join("\n â¨· "), rwrite_link)
        } else if (dwrite.length > 0) {
            $notify("ğŸ¤– " + "é‡å†™å¼•ç”¨  âŸ " + "âŸ¦" + subtag + "âŸ§", "â›”ï¸ ç­›é€‰å‚æ•°: " + pfi + pfo, "â˜ ï¸ é‡å†™ rewrite ä¸­å·²ç¦ç”¨ä»¥ä¸‹" + nowrite + "ä¸ªåŒ¹é…é¡¹:" + "\n â¨· " + dwrite.join("\n â¨· "), rwrite_link)
        }
    }
    if (Nlist.length == 0) { $notify("ğŸ¤– " + "é‡å†™å¼•ç”¨  âŸ " + "âŸ¦" + subtag + "âŸ§", "â›”ï¸ ç­›é€‰å‚æ•°: " + pfi + pfo, "âš ï¸ ç­›é€‰åå‰©ä½™rewriteè§„åˆ™æ•°ä¸º 0ï¸âƒ£ æ¡, è¯·æ£€æŸ¥å‚æ•°åŠåŸå§‹é“¾æ¥", nan_link) }
    if (hostname != "") { Nlist.push(hostname) }
    return Nlist
}

// ä¸»æœºåå¤„ç†
function HostNamecheck(content, parain, paraout) {
    var hname = content.replace(/ /g, "").split("=")[1].split(",");
    var nname = [];
    var dname = []; //åˆ é™¤é¡¹
    for (var i = 0; i < hname.length; i++) {
        dd = hname[i]
        const excludehn = (item) => dd.indexOf(item) != -1;
        if (paraout && paraout != "") { //å­˜åœ¨ out å‚æ•°æ—¶
            if (!paraout.some(excludehn)) { //out æœªå‘½ä¸­ğŸ¯ï¸
                if (parain && parain != "") {
                    if (parain.some(excludehn)) { //Pin å‘½ä¸­ğŸ¯ï¸
                        nname.push(hname[i])
                    } else {
                        $notify("..xx")
                        dname.push(hname[i])
                    } //Pin æœªå‘½ä¸­ğŸ¯ï¸çš„è®°å½•
                } else { nname.push(hname[i]) }	//æ— in å‚æ•°		
            } else { dname.push(hname[i]) } //out å‚æ•°å‘½ä¸­
        } else if (parain && parain != "") { //ä¸å­˜åœ¨ outï¼Œä½†æœ‰ in å‚æ•°æ—¶
            if (parain.some(excludehn)) { //Pin å‘½ä¸­ğŸ¯ï¸
                nname.push(hname[i])
            } else { dname.push(hname[i]) }
        } else {
            nname.push(hname[i])
        }
    } //for j
    hname = "hostname=" + nname.join(", ");
    if (Pntf0 != 0) {
        if (paraout || parain) {
            var noname = dname.length <= 10 ? emojino[dname.length] : dname.length
            var no1name = nname.length <= 10 ? emojino[nname.length] : nname.length
            if (parain && no1name != " 0ï¸âƒ£ ") {
                $notify("ğŸ¤– " + "é‡å†™å¼•ç”¨  âŸ " + "âŸ¦" + subtag + "âŸ§", "â›”ï¸ ç­›é€‰å‚æ•°: " + pfihn + pfohn, "â˜ ï¸ ä¸»æœºå hostname ä¸­å·²ä¿ç•™ä»¥ä¸‹" + no1name + "ä¸ªåŒ¹é…é¡¹:" + "\n â¨· " + nname.join(","), rwhost_link)
            } else if (dname.length > 0) {
                $notify("ğŸ¤– " + "é‡å†™å¼•ç”¨  âŸ " + "âŸ¦" + subtag + "âŸ§", "â›”ï¸ ç­›é€‰å‚æ•°: " + pfihn + pfohn, "â˜ ï¸ ä¸»æœºå hostname ä¸­å·²åˆ é™¤ä»¥ä¸‹" + noname + "ä¸ªåŒ¹é…é¡¹:" + "\n â¨· " + dname.join(","), rwhost_link)
            }
        }
    }
    if (nname.length == 0) {
        $notify("ğŸ¤– " + "é‡å†™å¼•ç”¨  âŸ " + "âŸ¦" + subtag + "âŸ§", "â›”ï¸ ç­›é€‰å‚æ•°: " + pfihn + pfohn, "âš ï¸ ä¸»æœºå hostname ä¸­å‰©ä½™ 0ï¸âƒ£ é¡¹, è¯·æ£€æŸ¥å‚æ•°åŠåŸå§‹é“¾æ¥", nan_link)
    }
    return hname
}

//Rewrite ç­›é€‰çš„å‡½æ•°
function Rcheck(content, param) {
    name = content.toUpperCase()
    if (param) {
        var flag = 0; //æ²¡å‘½ä¸­
        const checkpara = (item) => name.indexOf(item.toUpperCase()) != -1;
        if (param.some(checkpara)) {
            flag = 1 //å‘½ä¸­
        }
        return flag
    } else { //if param
        return 2
    } //æ— å‚æ•°
}

//åˆ†æµè§„åˆ™è½¬æ¢åŠè¿‡æ»¤ï¼Œå¯ç”¨äº surge åŠ quanx çš„ rule-list
function Rule_Handle(subs, Pout, Pin) {
    cnt = subs //.split("\n");
    Tin = Pin; //ä¿ç•™å‚æ•°
    Tout = Pout; //è¿‡æ»¤å‚æ•°
    ply = Ppolicy; //ç­–ç•¥ç»„
    var nlist = []
    var RuleK = ["//", "#", ";"];
    if (Tout != "" && Tout != null) { // æœ‰ out å‚æ•°æ—¶
        var dlist = [];
        for (var i = 0; i < cnt.length; i++) {
            cc = cnt[i]
            const exclude = (item) => cc.indexOf(item) != -1; // åˆ é™¤é¡¹
            const RuleCheck = (item) => cc.indexOf(item) != -1; //æ— è§†æ³¨é‡Šè¡Œ
            if (Tout.some(exclude) && !RuleK.some(RuleCheck)) {
                dlist.push(Rule_Policy("-" + cnt[i]))
            } else if (!RuleK.some(RuleCheck) && cc) { //if Pout.some, ä¸æ“ä½œæ³¨é‡Šé¡¹
                dd = Rule_Policy(cc);
                if (Tin != "" && Tin != null) {
                    const include = (item) => dd.indexOf(item) != -1; // ä¿ç•™é¡¹
                    if (Tin.some(include)) {
                        nlist.push(dd);
                    }
                } else {
                    nlist.push(dd);
                }
            } //else if cc
        }//for cnt
        var no = dlist.length <= 10 ? emojino[dlist.length] : dlist.length
        if (dlist.length > 0) {
            if (Pntf0 != 0) { $notify("ğŸ¤– " + "åˆ†æµå¼•ç”¨  âŸ " + "âŸ¦" + subtag + "âŸ§", "â›”ï¸ ç¦ç”¨: " + Tout, "â˜ ï¸ å·²ç¦ç”¨ä»¥ä¸‹" + no + "æ¡åŒ¹é…è§„åˆ™:" + "\n â¨· " + dlist.join("\n â¨· "), rule_link) }
        } else { $notify("ğŸ¤– " + "åˆ†æµå¼•ç”¨  âŸ " + "âŸ¦" + subtag + "âŸ§", "â›”ï¸ ç¦ç”¨: " + Tout, "âš ï¸ æœªå‘ç°ä»»ä½•åŒ¹é…é¡¹, è¯·æ£€æŸ¥å‚æ•°æˆ–åŸå§‹é“¾æ¥", nan_link) }
        if (Tin != "" && Tin != null) {  //æœ‰ in è·Ÿ out å‚æ•°æ—¶
            if (nlist.length > 0) {
                var noin0 = nlist.length <= 10 ? emojino[nlist.length] : nlist.length
                if (Pntf0 != 0) {
                    $notify("ğŸ¤– " + "åˆ†æµå¼•ç”¨  âŸ " + "âŸ¦" + subtag + "âŸ§", "âœ… ä¿ç•™:" + Tin, "ğŸ¯ å·²ä¿ç•™ä»¥ä¸‹ " + noin0 + "æ¡åŒ¹é…è§„åˆ™:" + "\n â¨ " + nlist.join("\n â¨ "), rule_link)
                }
            } else {
                $notify("ğŸ¤– " + "åˆ†æµå¼•ç”¨  âŸ " + "âŸ¦" + subtag + "âŸ§", "âœ… ä¿ç•™:" + Tin + ",â›”ï¸ ç¦ç”¨: " + Tout, "âš ï¸ ç­›é€‰åå‰©ä½™è§„åˆ™æ•°ä¸º 0ï¸âƒ£ æ¡, è¯·æ£€æŸ¥å‚æ•°åŠåŸå§‹é“¾æ¥", nan_link)
            }
        } else {// if Tin (No Tin)
            if (nlist.length == 0) {
                $notify("ğŸ¤– " + "åˆ†æµå¼•ç”¨  âŸ " + "âŸ¦" + subtag + "âŸ§", "â›”ï¸ ç¦ç”¨: " + Tout, "âš ï¸ ç­›é€‰åå‰©ä½™è§„åˆ™æ•°ä¸º 0ï¸âƒ£ æ¡, è¯·æ£€æŸ¥å‚æ•°åŠåŸå§‹é“¾æ¥", nan_link)
            }
        }
        return [...dlist, ...nlist];
    } else if (Tin != "" && Tin != null) { //if Tout
        var dlist = [];
        for (var i = 0; i < cnt.length; i++) {
            cc = cnt[i]
            const RuleCheck = (item) => cc.indexOf(item) != -1; //æ— è§†æ³¨é‡Šè¡Œ
            if (!RuleK.some(RuleCheck) && cc) { //if Pout.some, ä¸æ“ä½œæ³¨é‡Šé¡¹
                dd = Rule_Policy(cc);
                const include = (item) => dd.indexOf(item) != -1; // ä¿ç•™é¡¹
                if (Tin.some(include)) {
                    nlist.push(dd);
                } else { dlist.push("-" + dd) }
            }
        } // for cnt
        if (nlist.length > 0) {
            var noin = nlist.length <= 10 ? emojino[nlist.length] : nlist.length
            if (Pntf0 != 0) {
                $notify("ğŸ¤– " + "åˆ†æµå¼•ç”¨  âŸ " + "âŸ¦" + subtag + "âŸ§", "âœ… ä¿ç•™:" + Tin, "ğŸ¯ å·²ä¿ç•™ä»¥ä¸‹ " + noin + "æ¡åŒ¹é…è§„åˆ™:" + "\n â¨ " + nlist.join("\n â¨ "), rule_link)
            }
        } else { $notify("ğŸ¤– " + "åˆ†æµå¼•ç”¨  âŸ " + "âŸ¦" + subtag + "âŸ§", "âœ… ä¿ç•™:" + Tin, "âš ï¸ ç­›é€‰åå‰©ä½™è§„åˆ™æ•°ä¸º 0ï¸âƒ£ æ¡, è¯·æ£€æŸ¥å‚æ•°åŠåŸå§‹é“¾æ¥", nan_link) }
        return [...dlist, ...nlist];
    } else {  //if Tin
        return cnt.map(Rule_Policy)
    }
}

function Rule_Policy(content) { //å¢åŠ ã€æ›¿æ¢ policy
    var cnt = content.split(",");
    var RuleK = ["//", "#", ";"];
    var RuleK1 = ["host", "domain", "ip-cidr", "geoip", "user-agent", "ip6-cidr"];
    const RuleCheck = (item) => cnt[0].toLowerCase().indexOf(item) != -1; //æ— è§†æ³¨é‡Šè¡Œ
    const RuleCheck1 = (item) => cnt[0].toLowerCase().indexOf(item) != -1; //æ— è§† quanx ä¸æ”¯æŒçš„è§„åˆ™ç±»åˆ«
    if (RuleK1.some(RuleCheck1)) {
        if (cnt.length == 3 && cnt.indexOf("no-resolve") == -1) {
            ply0 = Ppolicy != "Shawn" ? Ppolicy : cnt[2]
            nn = cnt[0] + ", " + cnt[1] + ", " + ply0
        } else if (cnt.length == 2) { //Surge rule-set
            ply0 = Ppolicy != "Shawn" ? Ppolicy : "Shawn"
            nn = cnt[0] + ", " + cnt[1] + ", " + ply0
        } else if (cnt.length == 3 && cnt[2].indexOf("no-resolve") != -1) {
            ply0 = Ppolicy != "Shawn" ? Ppolicy : "Shawn"
            nn = cnt[0] + ", " + cnt[1] + ", " + ply0 + ", " + cnt[2]
        } else if (cnt.length == 4 && cnt[3].indexOf("no-resolve") != -1) {
            ply0 = Ppolicy != "Shawn" ? Ppolicy : cnt[2]
            nn = cnt[0] + ", " + cnt[1] + ", " + ply0 + ", " + cnt[3]
        } else if (!RuleK.some(RuleCheck) && content) {
            $notify("æœªèƒ½è§£æ" + "âŸ¦" + subtag + "âŸ§" + "å…¶ä¸­éƒ¨åˆ†è§„åˆ™:", content, nan_link);
            return ""
        } else { return "" }
        if (cnt[0].indexOf("URL-REGEX") != -1 || cnt[0].indexOf("PROCESS") != -1) {
            nn = ""
        } else { nn = nn.replace("IP-CIDR6", "ip6-cidr") }
        return nn
    } else { return "" }//if RuleK1 check	
}

// æ­£åˆ™æ›¿æ¢ filter/rewrite çš„éƒ¨åˆ†
// ç”¨é€”ï¼šå¦‚ tiktok æ¢åŒº: JP -> KR ï¼Œå¦‚æ·˜å®æ¯”ä»·è„šæœ¬ -> lite æ¨ªå¹…é€šçŸ¥ç‰ˆæœ¬
function ReplaceReg(cnt, para) {
    var cnt0 = cnt.join("\n")
    var pp = para.split("+")
    for (var i = 0; i < pp.length; i++) {
        var p1 = pp[i].split("@")[0]
        var p2 = pp[i].split("@")[1]
        p1 = new RegExp(p1, "gmi")
        cnt0 = cnt0.replace(p1, p2)
    }
    return cnt0.split("\n")
}

//æ··åˆè®¢é˜…ç±»å‹ï¼Œç”¨äºæ•´ä½“è¿›è¡Œäº† base64 encode åçš„ç±»å‹
function SubsEd2QX(subs, Pudp, Ptfo, Pcert, Ptls13) {
    var list0 = Base64.decode(subs).split("\n");
    var QuanXK = ["shadowsocks=", "trojan=", "vmess=", "http="];
    var SurgeK = ["=ss", "=vmess", "=trojan", "=http", "=custom"];
    var LoonK = ["=shadowsocks", "=shadowsocksr"]
    var QXlist = [];
    for (var i = 0; i < list0.length; i++) {
        var node = ""
        if (list0[i].trim().length > 3) {
            var type = list0[i].split("://")[0].trim()
            var listi = list0[i].replace(/ /g, "")
            const QuanXCheck = (item) => listi.toLowerCase().indexOf(item) != -1;
            const SurgeCheck = (item) => listi.toLowerCase().indexOf(item) != -1;
            const LoonCheck = (item) => listi.toLowerCase().indexOf(item) != -1;
            if (type == "vmess" && list0[i].indexOf("remarks=") == -1) {
                var bnode = Base64.decode(list0[i].split("vmess://")[1])
                if (bnode.indexOf("over-tls=") == -1) { //v2rayN
                    node = V2QX(list0[i], Pudp, Ptfo, Pcert, Ptls13)
                } else { //quantumult ç±»å‹
                    node = VQ2QX(list0[i], Pudp, Ptfo, Pcert, Ptls13)
                }
            } else if (type == "vmess" && list0[i].indexOf("remarks=") != -1) { //shadowrocket ç±»å‹
                node = VR2QX(list0[i], Pudp, Ptfo, Pcert, Ptls13)
            } else if (type == "ssr") {
                node = SSR2QX(list0[i], Pudp, Ptfo)
            } else if (type == "ss") {
                node = SS2QX(list0[i], Pudp, Ptfo)
            } else if (type == "trojan") {
                node = TJ2QX(list0[i], Pudp, Ptfo, Pcert, Ptls13)
            } else if (type == "https" && listi.indexOf("@") != -1) { //subs,Ptfo,Pcert,Ptls13
                node = HPS2QX(list0[i], Ptfo, Pcert, Ptls13)
            } else if (QuanXK.some(QuanXCheck)) {
                node = list0[i]
            } else if (SurgeK.some(SurgeCheck)) {
                node = Surge2QX(list0[i])
            } else if (LoonK.some(LoonCheck)) {
                node = Loon2QX(list0[i])
            }
            if (node != "") {
                QXlist.push(node)
            }
        }
    }
    return QXlist
}

//æ··åˆè®¢é˜…ç±»å‹ï¼Œç”¨äºæœªæ•´ä½“è¿›è¡Œ base64 encode çš„ç±»å‹
function Subs2QX(subs, Pudp, Ptfo, Pcert, Ptls13) {
    var list0 = subs.split("\n");
    var QuanXK = ["shadowsocks=", "trojan=", "vmess=", "http="];
    var SurgeK = ["=ss", "=vmess", "=trojan", "=http"];
    var LoonK = ["=shadowsocks", "=shadowsocksr"]
    var QXlist = [];
    for (var i = 0; i < list0.length; i++) {
        var node = ""
        if (list0[i].trim().length > 3) {
            var type = list0[i].split("://")[0].trim()
            var listi = list0[i].replace(/ /g, "")
            const QuanXCheck = (item) => listi.toLowerCase().indexOf(item) != -1;
            const SurgeCheck = (item) => listi.toLowerCase().indexOf(item) != -1;
            const LoonCheck = (item) => listi.toLowerCase().indexOf(item) != -1;
            if (type == "vmess" && list0[i].indexOf("remarks=") == -1) {
                var bnode = Base64.decode(list0[i].split("vmess://")[1])
                if (bnode.indexOf("over-tls=") == -1) { //v2rayN
                    node = V2QX(list0[i], Pudp, Ptfo, Pcert, Ptls13)
                } else { //quantumult ç±»å‹
                    node = VQ2QX(list0[i], Pudp, Ptfo, Pcert, Ptls13)
                }
            } else if (type == "vmess" && list0[i].indexOf("remarks=") != -1) { //shadowrocket ç±»å‹
                node = VR2QX(list0[i], Pudp, Ptfo, Pcert, Ptls13)
            } else if (type == "ssr") {
                node = SSR2QX(list0[i], Pudp, Ptfo)
            } else if (type == "ss") {
                node = SS2QX(list0[i], Pudp, Ptfo)
            } else if (type == "ssd") {
                node = SSD2QX(list0[i], Pudp, Ptfo)
            } else if (type == "trojan") {
                node = TJ2QX(list0[i], Pudp, Ptfo, Pcert, Ptls13)
            } else if (type == "https" && listi.indexOf("@") != -1) {
                node = HPS2QX(list0[i], Ptfo, Pcert, Ptls13)
            } else if (QuanXK.some(QuanXCheck)) {
                node = list0[i]
            } else if (SurgeK.some(SurgeCheck)) {
                node = Surge2QX(list0[i])
            } else if (LoonK.some(LoonCheck)) {
                node = Loon2QX(list0[i])
            }
            if (node instanceof Array) {
                for (var j in node) {
                    QXlist.push(node[j])
                }
            } else if (node != "") {
                QXlist.push(node)
            }
        }
    }
    return QXlist
}

// æ£€æŸ¥èŠ‚ç‚¹åå­—(é‡å¤ä»¥åŠç©ºå)ç­‰QuanX ä¸å…è®¸çš„æƒ…å½¢
function TagCheck_QX(content) {
    var Olist = content
    var Nlist = []
    var nmlist = []
    var nulllist = []; //è®°å½•ç©ºåå­—èŠ‚ç‚¹
    var duplist = [];  //è®°å½•é‡åèŠ‚ç‚¹
    var no = 0;
    for (var i = 0; i < Olist.length; i++) {
        var item = Olist[i] ? Olist[i] : ""
        if (item.replace(/ /gm, "").indexOf("tag=") != -1) {
            var nl = item.slice(item.indexOf("tag"))
            var nm = nl.slice(nl.indexOf("=") + 1)
            if (nm == "") { //ç©ºåå­—
                nm = " [" + item.split("=")[0] + "] " + item.split("=")[1].split(",")[0].split(":")[0]
                item = item.split("tag")[0] + "tag=" + nm.replace("shadowsocks", "ss")
                nulllist.push(nm.replace("shadowsocks", "ss"))
            }
            var ni = 0
            while (nmlist.indexOf(nm) != -1) { //é‡å
                nm = ni <= 10 ? nm.split(" âŒ˜")[0] + " âŒ˜" + emojino[ni] : nm.split(" âŒ˜")[0] + " âŒ˜" + ni
                item = item.split("tag")[0] + "tag=" + nm
                ni = ni + 1
            }
            if (ni != 0) { duplist.push(nm) }
            nmlist.push(nm)
            ni = 0
            Nlist.push(item)
        }// if "tag="
    } // for
    if (nulllist.length >= 1) {
        no = nulllist.length <= 10 ? emojino[nulllist.length] : nulllist.length;
        $notify("âš ï¸ å¼•ç”¨" + "âŸ¦" + subtag + "âŸ§" + " å†…æœ‰" + no + "ä¸ªç©ºèŠ‚ç‚¹å ", "âœ… å·²å°†èŠ‚ç‚¹â€œç±»å‹+IPâ€è®¾ä¸ºèŠ‚ç‚¹å", " â¨ " + nulllist.join("\n â¨ "), nan_link)
    }
    if (duplist.length >= 1) {
        no = duplist.length <= 10 ? emojino[duplist.length] : duplist.length;
        $notify("âš ï¸ å¼•ç”¨" + "âŸ¦" + subtag + "âŸ§" + " å†…æœ‰" + no + "ä¸ªé‡å¤èŠ‚ç‚¹å ", "âœ… å·²æ·»åŠ âŒ˜ç¬¦å·ä½œä¸ºåŒºåˆ†:", " â¨ " + duplist.join("\n â¨ "), nan_link)
    }
    return Nlist
}
//http=example.com:443, username=name, password=pwd, over-tls=true, tls-host=example.com, tls-verification=true, tls13=true, fast-open=false, udp-relay=false, tag=http-tls-02
//HTTPS ç±»å‹ URI è½¬æ¢æˆ QUANX æ ¼å¼
function HPS2QX(subs, Ptfo, Pcert, Ptls13) {
    var server = Base64.decode(subs.replace("https://", "")).trim().split("\u0000")[0];
    var nss = []
    if (server != "") {
        var ipport = "http=" + server.split("@")[1].split("#")[0].split("/")[0];
        var uname = "username=" + server.split(":")[0];
        var pwd = "password=" + server.split("@")[0].split(":")[1];
        var tag = "tag=" + server.split("#")[1];
        var tls = "over-tls=true";
        var cert = Pcert != 0 ? "tls-verification=true" : "tls-verification=false";
        var tfo = Ptfo == 1 ? "fast-open=true" : "fast-open=false";
        var tls13 = Ptls13 == 1 ? "tls13=true" : "tls13=false";
        nss.push(ipport, uname, pwd, tls, cert, tfo, tls13, tag)
    }
    var QX = nss.join(",");
    return QX
}

//quantumult æ ¼å¼çš„ vmess URI è½¬æ¢
function VQ2QX(subs, Pudp, Ptfo, Pcert, Ptls13) {
    var server = String(Base64.decode(subs.replace("vmess://", "").trim()).split("\u0000")[0])
    var node = ""
    var ip = "vmess=" + server.split(",")[1].trim() + ":" + server.split(",")[2].trim() + ", " + "method=aes-128-gcm, " + "password=" + server.split(",")[4].split("\"")[1] + ", "
    var tag = "tag=" + server.split("=")[0]
    var tfo = subs.indexOf("tfo=1") != -1 ? "fast-open=true, " : "fast-open=false, "
    var udp = Pudp == 1 ? "udp-relay=true, " : "udp-relay=false, ";
    node = ip + tfo + udp
    var obfs = ""
    if (server.indexOf("obfs=") == -1) { // é ws ç±»å‹
        obfs = server.indexOf("over-tls=true") != -1 ? "obfs=over-tls, " : "" //over-tls
        var host = server.indexOf("tls-host") != -1 ? "obfs-host=" + server.split("tls-host=")[1].split(",")[0] + ", " : ""
        obfs = obfs + host
    } else if (server.indexOf("obfs=ws") != -1) {
        obfs = server.indexOf("over-tls=true") != -1 ? "obfs=wss, " : "obfs=ws, " //ws,wss ç±»å‹
        var uri = server.indexOf("obfs-path=") != -1 ? "obfs-uri=" + server.split("obfs-path=")[1].split("\"")[1] + ", " : "obfs-uri=/, "
        obfs = obfs + uri
        var host = server.indexOf("obfs-header=") != -1 ? "obfs-host=" + server.split("obfs-header=\"Host:")[1].split("[")[0].trim() + ", " : ""
        obfs = obfs + host
    }
    if (obfs.indexOf("obfs=over-tls") != -1 || obfs.indexOf("obfs=wss") != -1) {
        var cert = Pcert != 0 || subs.indexOf("allowInsecure=1") != -1 ? "tls-verification=false, " : "tls-verification=true, "
        var tls13 = Ptls13 == 1 ? "tls13=true, " : ""
        obfs = obfs + cert + tls13
    }
    node = node + obfs + tag
    return node
}

//Shadowrocket æ ¼å¼çš„ vmess URI è½¬æ¢
function VR2QX(subs, Pudp, Ptfo, Pcert, Ptls13) {
    var server = String(Base64.decode(subs.replace("vmess://", "").split("?remarks")[0]).trim()).split("\u0000")[0]
    var node = ""
    var ip = "vmess=" + server.split("@")[1] + ", " + "method=aes-128-gcm, " + "password=" + server.split("@")[0].split(":")[1] + ", "
    var tag = "tag=" + decodeURIComponent(subs.split("remarks=")[1].split("&")[0])
    var tfo = subs.indexOf("tfo=1") != -1 ? "fast-open=true, " : "fast-open=false, "
    var udp = Pudp == 1 ? "udp-relay=true, " : "udp-relay=false, ";
    node = ip + tfo + udp
    var obfs = subs.split("obfs=")[1].split("&")[0]
    if (obfs == "none") { //
        obfs = subs.indexOf("tls=1") != -1 ? "obfs=over-tls, " : "" //over-tls
    } else if (obfs == "websocket") {
        obfs = subs.indexOf("tls=1") != -1 ? "obfs=wss, " : "obfs=ws," //ws,wss ç±»å‹
        obfs = obfs + "obfs-uri=" + subs.split("&path=")[1].split("&")[0] + ", "
        var host = subs.indexOf("&obfsParam=") != -1 ? "obfs-host=" + subs.split("&obfsParam=")[1].split("&")[0] + ", " : ""
        obfs = obfs + host
    }
    if (obfs.indexOf("obfs=over-tls") != -1 || obfs.indexOf("obfs=wss") != -1) {
        var cert = Pcert != 0 || subs.indexOf("allowInsecure=1") != -1 ? "tls-verification=false, " : "tls-verification=true, "
        var tls13 = Ptls13 == 1 ? "tls13=true, " : ""
        obfs = obfs + cert + tls13
    }
    node = node + obfs + tag
    return node
}

//V2RayN uriè½¬æ¢æˆ QUANX æ ¼å¼
function V2QX(subs, Pudp, Ptfo, Pcert, Ptls13) {
    var cert = Pcert
    var tls13 = Ptls13
    var server = String(Base64.decode(subs.replace("vmess://", "")).trim()).split("\u0000")[0];
    var nss = [];
    if (server != "") {
        ss = JSON.parse(server);
        ip = "vmess=" + ss.add + ":" + ss.port;
        pwd = "password=" + ss.id;
        mtd = "method=aes-128-gcm"
        tag = "tag=" + decodeURIComponent(ss.ps);
        udp = Pudp == 1 ? "udp-relay=true" : "udp-relay=false";
        tfo = Ptfo == 1 ? "fast-open=true" : "fast-open=false";
        obfs = Pobfs(ss, cert, tls13);
        if (obfs == "" || obfs == undefined) {
            nss.push(ip, mtd, pwd, tfo, udp, tag)
        } else {
            nss.push(ip, mtd, pwd, obfs, tfo, udp, tag);
        }
        QX = nss.join(", ");
    }
    return QX
}

// Vmess obfs å‚æ•°
function Pobfs(jsonl, Pcert, Ptls13) {
    var obfsi = [];
    var cert = Pcert;
    tcert = cert == 0 ? "tls-verification=false" : "tls-verification=true";
    tls13 = Ptls13 == 1 ? "tls13=true" : "tls13=false"
    if (jsonl.net == "ws" && jsonl.tls == "tls") {
        obfs0 = "obfs=wss, " + tcert + ", " + tls13 + ", ";
        uri0 = jsonl.path && jsonl.path != "" ? "obfs-uri=" + jsonl.path : "obfs-uri=/";
        host0 = jsonl.host && jsonl.host != "" ? "obfs-host=" + jsonl.host + "," : "";
        obfsi.push(obfs0 + host0 + uri0)
        return obfsi.join(", ")
    } else if (jsonl.net == "ws") {
        obfs0 = "obfs=ws";
        uri0 = jsonl.path && jsonl.path != "" ? "obfs-uri=" + jsonl.path : "obfs-uri=/";
        host0 = jsonl.host && jsonl.host != "" ? "obfs-host=" + jsonl.host + "," : "";
        obfsi.push(obfs0, host0 + uri0);
        return obfsi.join(", ")
    } else if (jsonl.tls == "tls") {
        obfs0 = "obfs=over-tls, " + tcert + ", " + tls13;
        uri0 = jsonl.path && jsonl.path != "" ? "obfs-uri=" + jsonl.path : "";
        host0 = jsonl.host && jsonl.host != "" ? ", obfs-host=" + jsonl.host : "";
        obfsi.push(obfs0 + host0)
        return obfsi.join(", ")
    }
}

//å¯¹.çš„ç‰¹æ®Šå¤„ç†(in/out & renameä¸­)
function Dot2(cnt) {
    cnt = cnt ? cnt.replace(/\\\./g, "è¿™æ˜¯ä¸ªç‚¹") : ""
    return cnt
}

function ToDot(cnt) {
    cnt = cnt ? cnt.replace(/è¿™æ˜¯ä¸ªç‚¹/g, ".") : ""
    return cnt
}

//æ­£åˆ™ç­›é€‰, å®Œæ•´å†…å®¹åŒ¹é…
function Regex(content) {
    Preg = RegExp(Preg, "i")
    cnt = content //.split("tag=")[1]
    if (Preg.test(cnt)) {
        return content
    }
}

// åˆ¤æ–­èŠ‚ç‚¹è¿‡æ»¤çš„å‡½æ•°
function Scheck(content, param) {
    name = content.split("tag=")[1].toUpperCase()
    param = param ? param.map(Dot2) : param // å¯¹ç¬¦å·.çš„ç‰¹æ®Šå¤„ç†
    if (param) {
        var flag = 0;
        for (var i = 0; i < param.length; i++) {
            var params = param[i].split(".").map(ToDot);
            const checkpara = (item) => name.indexOf(item.toUpperCase()) != -1;
            if (params.every(checkpara)) {
                flag = 1
            }
        }//for
        return flag
    } else { //if param
        return 2
    }
}

//èŠ‚ç‚¹è¿‡æ»¤ï¼Œä½¿ç”¨+è¿æ¥å¤šä¸ªå…³é”®è¯(é€»è¾‘"æˆ–"):in ä¸ºä¿ç•™ï¼Œout ä¸ºæ’é™¤, "ä¸"é€»è¾‘è¯·ç”¨ç¬¦å·"."è¿æ¥
function Filter(servers, Pin, Pout) {
    var Nlist = [];
    var Delist = [];
    var Nname = [];
    for (var i = 0; i < servers.length; i++) {
        if (Scheck(servers[i], Pin) != 0 && Scheck(servers[i], Pout) != 1) {
            Nlist.push(servers[i])
            Nname.push(servers[i].replace(/ /g, "").split("tag=")[1])
        } else { Delist.push(servers[i].replace(/ /g, "").split("tag=")[1]) } //è®°å½•æœªè¢«ä¿ç•™èŠ‚ç‚¹
    }//for
    var no = Delist.length <= 10 ? emojino[Delist.length] : Delist.length;
    var no1 = Nlist.length <= 10 ? emojino[Nlist.length] : Nlist.length;
    if (Pntf0 == 1 && Delist.length >= 1) {//é€šçŸ¥éƒ¨åˆ†
        if (Pin && no1 > 0) { //æœ‰ in å‚æ•°å°±é€šçŸ¥ä¿ç•™éƒ¨åˆ†
            $notify("ğŸ‘¥ å¼•ç”¨" + "âŸ¦" + subtag + "âŸ§" + " å¼€å§‹èŠ‚ç‚¹ç­›é€‰", "ğŸ•¹ ç­›é€‰å…³é”®å­—: " + pfi + pfo, "â˜ ï¸ å·²ä¿ç•™ä»¥ä¸‹ " + no1 + "ä¸ªèŠ‚ç‚¹\n" + Nname.join(", "), sub_link);
        } else if (Pout && no > 0) {
            $notify("ğŸ‘¥ å¼•ç”¨" + "âŸ¦" + subtag + "âŸ§" + " å¼€å§‹èŠ‚ç‚¹ç­›é€‰", "ğŸ•¹ ç­›é€‰å…³é”®å­—: " + pfi + pfo, "â˜ ï¸ å·²åˆ é™¤ä»¥ä¸‹ " + no + "ä¸ªèŠ‚ç‚¹\n" + Delist.join(", "), sub_link);
        }
    } else if (no1 == 0 || no1 == null) { //æ— å‰©ä½™èŠ‚ç‚¹æ—¶å¼ºåˆ¶é€šçŸ¥
        $notify("â€¼ï¸ âŸ¦" + subtag + "âŸ§" + "ç­›é€‰åèŠ‚ç‚¹æ•°ä¸º0ï¸âƒ£", "âš ï¸ è¯·è‡ªè¡Œæ£€æŸ¥åŸå§‹é“¾æ¥ä»¥åŠç­›é€‰å‚æ•°", link0, sub_link);
    }
    return Nlist
}

function FilterScript(servers, script) {
    $notify("ğŸ¤– å¯ç”¨è„šæœ¬è¿›è¡Œç­›é€‰", "", script);
    try {
        const $ = Tools();
        eval(script);
        // extract server tags
        const nodes = Tools().getNodeInfo(servers);
        const IN = filter(nodes);
        const res = servers.filter((_, i) => IN[i]);
        if (res.length === 0) {
            $notify("â€¼ï¸ âŸ¦" + subtag + "âŸ§" + "ç­›é€‰åèŠ‚ç‚¹æ•°ä¸º0ï¸âƒ£", "âš ï¸ è¯·è‡ªè¡Œæ£€æŸ¥åŸå§‹é“¾æ¥ä»¥åŠç­›é€‰å‚æ•°", link0, sub_link);
        }
        return res;
    } catch (err) {
        $notify("âŒ è„šæœ¬ç­›é€‰å‡ºç°é”™è¯¯", "", err);
        return servers;
    }
}

//SSR ç±»å‹ URI è½¬æ¢ quanx æ ¼å¼
function SSR2QX(subs, Pudp, Ptfo) {
    var nssr = []
    var cnt = Base64.decode(subs.split("ssr://")[1].replace(/-/g, "+").replace(/_/g, "/")).split("\u0000")[0]
    var obfshost = '';
    var oparam = '';
    if (cnt.split(":").length <= 6) { //æ’é™¤éš¾æçš„ ipv6 èŠ‚ç‚¹
        type = "shadowsocks=";
        ip = cnt.split(":")[0] + ":" + cnt.split(":")[1];
        pwd = "password=" + Base64.decode(cnt.split("/?")[0].split(":")[5].replace(/-/g, "+").replace(/_/g, "/")).split("\u0000")[0];
        mtd = "method=" + cnt.split(":")[3];
        obfs = "obfs=" + cnt.split(":")[4] + ", ";
        ssrp = "ssr-protocol=" + cnt.split(":")[2];
        if (cnt.indexOf("obfsparam=") != -1) {
            obfshost = cnt.split("obfsparam=")[1].split("&")[0] != "" ? "obfs-host=" + Base64.decode(cnt.split("obfsparam=")[1].split("&")[0].replace(/-/g, "+").replace(/_/g, "/")).split(",")[0].split("\u0000")[0] + ", " : ""
        }
        if (cnt.indexOf("protoparam=") != -1) {
            oparam = cnt.split("protoparam=")[1].split("&")[0] != "" ? "ssr-protocol-param=" + Base64.decode(cnt.split("protoparam=")[1].split("&")[0].replace(/-/g, "+").replace(/_/g, "/")).split(",")[0].split("\u0000")[0] + ", " : ""
        }
        tag = "tag=" + (Base64.decode(cnt.split("remarks=")[1].split("&")[0].replace(/-/g, "+").replace(/_/g, "/"))).split("\u0000")[0]
        pudp = Pudp == 1 ? "udp-relay=true" : "udp-relay=false";
        ptfo = Ptfo == 1 ? "fast-open=true" : "fast-open=false";
        nssr.push(type + ip, pwd, mtd, obfs + obfshost + oparam + ssrp, pudp, ptfo, tag)
        QX = nssr.join(", ")
    } else { QX = "" }
    return QX;
}

//Trojan ç±»å‹ URI è½¬æ¢æˆ QX
function TJ2QX(subs, Pudp, Ptfo, Pcert, Ptls13) {
    var ntrojan = []
    var cnt = subs.split("trojan://")[1]
    type = "trojan=";
    if (cnt.indexOf(":443") != -1) {
        ip = cnt.split("@")[1].split(":443")[0] + ":443";
    } else {
        ip = cnt.split("@")[1].split("?")[0].split("\n")[0].trim(); //é 443 ç«¯å£çš„å¥‡è‘©æœºåœºï¼Ÿ
    }
    pwd = "password=" + cnt.split("@")[0];
    obfs = "over-tls=true";
    pcert = cnt.indexOf("allowInsecure=0") != -1 ? "tls-verification=true" : "tls-verification=false";
    ptls13 = Ptls13 == 1 ? "tls13=true" : "tls13=false"
    if (Pcert == 0) { pcert = "tls-verification=false" }
    pudp = Pudp == 1 ? "udp-relay=true" : "udp-relay=false";
    ptfo = Ptfo == 1 ? "fast-open=true" : "fast-open=false";
    tag = cnt.indexOf("#") != -1 ? "tag=" + decodeURIComponent(cnt.split("#")[1]) : "tag= [trojan]" + ip
    ntrojan.push(type + ip, pwd, obfs, pcert, ptls13, pudp, ptfo, tag)
    QX = ntrojan.join(", ");
    return QX;
}

//SS ç±»å‹ URI è½¬æ¢ quanx æ ¼å¼
function SS2QX(subs, Pudp, Ptfo) {
    var nssr = []
    var cnt = subs.split("ss://")[1]
    if (cnt.split(":").length <= 6) { //æ’é™¤éš¾æçš„ ipv6 èŠ‚ç‚¹
        type = "shadowsocks=";
        if (cnt.indexOf("@") != -1) {
            ip = cnt.split("@")[1].split("#")[0].split("/")[0];
            pwdmtd = Base64.decode(cnt.split("@")[0].replace(/-/g, "+").replace(/_/g, "/")).split("\u0000")[0].split(":")
        } else {
            var cnt0 = Base64.decode(cnt.split("#")[0].replace(/-/g, "+").replace(/_/g, "/").split("\u0000")[0]);
            ip = cnt0.split("@")[1].split("#")[0].split("/")[0];
            pwdmtd = cnt0.split("@")[0].split(":")
        }
        pwd = "password=" + pwdmtd[1];
        mtd = "method=" + pwdmtd[0];
        obfs = cnt.split("obfs%3D")[1] != null ? ", obfs=" + cnt.split("obfs%3D")[1].split("%3B")[0] : "";
        obfshost = cnt.split("obfs-host%3D")[1] != null ? ", obfs-host=" + cnt.split("obfs-host%3D")[1].split("&")[0].split("#")[0] : "";
        tag = "tag=" + decodeURIComponent(cnt.split("#")[1])
        pudp = Pudp == 1 ? "udp-relay=true" : "udp-relay=false";
        ptfo = Ptfo == 1 ? "fast-open=true" : "fast-open=false";
        nssr.push(type + ip, pwd, mtd + obfs + obfshost, pudp, ptfo, tag)
        QX = nssr.join(", ")
        return QX;
    }
}

//SSD ç±»å‹ URI è½¬æ¢ quanx æ ¼å¼
function SSD2QX(subs, Pudp, Ptfo) {
    var j = 0
    var QX = []
    var cnt = JSON.parse(Base64.decode(subs.split("ssd://")[1]))
    var type = "shadowsocks=";
    var pwd = "password=" + cnt.password;
    var mtd = "method=" + cnt.encryption;
    var obfs = ""
    var obfshost = ""
    var port = cnt.port ? ":" + cnt.port : ""
    if (cnt.plugin_options) {
        obfs = cnt.plugin_options.split(";")[0] != null ? ", " + cnt.plugin_options.split(";")[0] : "";
        obfshost = cnt.plugin_options.split(";")[1] != null ? ", " + cnt.plugin_options.split(";")[1] : "";
    }
    pudp = Pudp == 1 ? "udp-relay=true" : "udp-relay=false";
    ptfo = Ptfo == 1 ? "fast-open=true" : "fast-open=false";
    for (var i in cnt.servers) {
        ip = cnt.servers[i].server;
        if (cnt.servers[i].plugin_options) {
            obfs = cnt.servers[i].plugin_options.split(";")[0] != null ? ", " + cnt.servers[i].plugin_options.split(";")[0] : "";
            obfshost = cnt.servers[i].plugin_options.split(";")[1] != null ? ", " + cnt.servers[i].plugin_options.split(";")[1] : "";
        }
        if (cnt.servers[i].encryption) {  //ç‹¬ç«‹çš„åŠ å¯†æ–¹å¼
            mtd = "method=" + cnt.servers[i].encryption
        }
        if (cnt.servers[i].password) {  //ç‹¬ç«‹çš„å¯†ç 
            pwd = "password=" + cnt.servers[i].password
        }
        if (ip.indexOf(".") > 0) { //æ’é™¤éš¾æçš„ ipv6 èŠ‚ç‚¹
            port = cnt.servers[i].port ? ":" + cnt.servers[i].port : port;
            tag = "tag=" + cnt.servers[i].remarks;
            QX[j] = type + ip + port + ", " + pwd + ", " + mtd + obfs + obfshost + ", " + pudp + ", " + ptfo + ", " + tag;
            var j = j + 1;
        }
    }
    return QX;
}

// ç”¨äºè¿‡æ»¤éèŠ‚ç‚¹éƒ¨åˆ†ï¼ˆæ¯”å¦‚æ•´ä»½é…ç½®ä¸­å…¶å®ƒå†…å®¹ï¼‰
function isQuanX(content) {
    var cnts = content.split("\n");
    var nlist = []
    for (var i = 0; i < cnts.length; i++) {
        var cnti = cnts[i];
        if (cnti.indexOf("=") != -1 && cnti.indexOf("tag") != -1) {
            var cnt = cnti.split("=")[0].trim()
            if (cnt == "http" || cnt == "shadowsocks" || cnt == "trojan" || cnt == "vmess") {
                nlist.push(cnti)
            }
        }
    }
    return nlist
}

//æ ¹æ®èŠ‚ç‚¹åæ’åº(ä¸å«emoji éƒ¨åˆ†)
function QXSort(content, para) {
    var nlist = content;//.split("\n");
    if (para == 1) {
        return nlist.sort(ToTag)
    } else if (para == -1) {
        return nlist.sort(ToTagR)
    }
}
//æ­£åº
function ToTag(elem1, elem2) {
    var tag1 = emoji_del(elem1.split("tag")[1].split("=")[1].trim())
    var tag2 = emoji_del(elem2.split("tag")[1].split("=")[1].trim())
    res = tag1 > tag2 ? 1 : -1
    return res
}
//é€†åº
function ToTagR(elem1, elem2) {
    var tag1 = emoji_del(elem1.split("tag")[1].split("=")[1].trim())
    var tag2 = emoji_del(elem2.split("tag")[1].split("=")[1].trim())
    res = tag1 > tag2 ? -1 : 1
    return res
}

//æ­£åˆ™åˆ é™¤èŠ‚ç‚¹åå†…çš„å­—ç¬¦
function DelReg(content) {
    delreg = RegExp(delreg, "gmi")
    cnt0 = content.split("tag=")[0]
    cnt1 = content.split("tag=")[1]
    cnt = cnt0 + "tag=" + cnt1.replace(delreg, "")
    return cnt
}

//èŠ‚ç‚¹é‡å‘½å
function Rename(str) {
    var server = str;
    if (server.indexOf("tag=") != -1) {
        hd = server.split("tag=")[0]
        name = server.split("tag=")[1].trim()
        for (var i = 0; i < Prn.length; i++) {
            nname = Prn[i].split("@")[1] ? decodeURIComponent(Prn[i].split("@")[1]) : Prn[i].split("@")[1];
            oname = Prn[i].split("@")[0] ? decodeURIComponent(Prn[i].split("@")[0]) : Prn[i].split("@")[0];
            if (oname && nname) { //é‡å‘½å
                var rn = escapeRegExp(oname)
                name = name.replace(new RegExp(rn, "gmi"), nname)
            } else if (oname && nname == "") {//å‰ç¼€
                var nemoji = emoji_del(name)
                if (Pemoji == 1 || Pemoji == 2) { //åˆ¤æ–­æ˜¯å¦æœ‰é‡å¤ emojiï¼Œæœ‰åˆ™åˆ é™¤æ—§æœ‰
                    name = name.replace(name.split(" ")[0] + " ", name.split(" ")[0] + " " + oname)
                } else { name = oname + name }
            } else if (nname && oname == "") {//åç¼€
                name = name + nname
            } else if (oname && oname.indexOf("â˜ ï¸") != -1) { //åˆ é™¤ç‰¹å®šå­—ç¬¦ï¼Œå¤šå­—ç¬¦ç”¨.è¿æ¥
                hh = Dot2(oname.slice(0, oname.length - 2)).split(".") //ç¬¦å·.çš„ç‰¹æ®Šå¤„ç†
                for (j = 0; j < hh.length; j++) {
                    var nn = escapeRegExp(ToDot(hh[j]))
                    var del = new RegExp(nn, "gmi");
                    name = name.replace(del, "")
                }
            } else if (oname == "" && nname == "") { //ä»…æœ‰@æ—¶ï¼Œåˆ é™¤@ç¬¦å·
                name = name.replace(/@/g, "")
            } else {
                name = name
            }
            nserver = hd + "tag=" + name
        }
    } return nserver
}

function RenameScript(servers, script) {
    $notify("ğŸ¤– å¯ç”¨è„šæœ¬è¿›è¡Œé‡å‘½å", "", script);
    try {
        const $ = Tools().rename;
        // extract server tags
        const nodes = Tools().getNodeInfo(servers);
        eval(script);
        const newNames = rename(nodes);
        // rename nodes
        return servers.map((s, i) => s.split("tag=")[0] + "tag=" + newNames[i]);
    } catch (err) {
        $notify("âŒ è„šæœ¬é‡å‘½åå‡ºç°é”™è¯¯", "", err);
        return servers;
    }

}

//åˆ é™¤ emoji 
function emoji_del(str) {
    return unescape(escape(str).replace(/\%uD.{3}/g, ''));
}

//ä¸ºèŠ‚ç‚¹åæ·»åŠ  emoji
function get_emoji(source, sname) {
    var cnt = source;
    var flag = 0;
    for (var key in cnt) {
        dd = cnt[key]
        for (i in dd) {
            if (sname.indexOf(dd[i]) != -1) {
                flag = 1;
                nname = key + " " + sname.replace(/[\uD83C][\uDDE6-\uDDFF][\uD83C][\uDDE6-\uDDFF]/g, "").trim(); // use regex to remove the original flag
                return nname
            }
        }
    }
    if (flag == 0) { return "ğŸ´â€â˜ ï¸ " + sname.trim() }
}

//emoji å¤„ç†
function emoji_handle(servers, Pemoji) {
    var nlist = []
    var ser0 = servers
    for (var i = 0; i < ser0.length; i++) {
        if (ser0[i].indexOf("tag=") != -1) {
            var oname = ser0[i].split("tag=")[1].trim();
            var hd = ser0[i].split("tag=")[0];
            var nname = oname;//emoji_del(oname);
            var Lmoji = { "ğŸ³ï¸â€ğŸŒˆ": ["æµé‡", "æ—¶é—´", "åº”æ€¥", "è¿‡æœŸ", "Bandwidth", "expire"], "ğŸ‡¦ğŸ‡¨": ["AC"], "ğŸ‡¦ğŸ‡¹": ["å¥¥åœ°åˆ©", "ç»´ä¹Ÿçº³"], "ğŸ‡¦ğŸ‡º": ["AU", "Australia", "Sydney", "æ¾³å¤§åˆ©äºš", "æ¾³æ´²", "å¢¨å°”æœ¬", "æ‚‰å°¼"], "ğŸ‡§ğŸ‡ª": ["BE", "æ¯”åˆ©æ—¶"], "ğŸ‡§ğŸ‡¬": ["ä¿åŠ åˆ©äºš", "Bulgaria"], "ğŸ‡§ğŸ‡·": ["BR", "Brazil", "å·´è¥¿", "åœ£ä¿ç½—"], "ğŸ‡¨ğŸ‡¦": ["Canada", "Waterloo", "åŠ æ‹¿å¤§", "è’™ç‰¹åˆ©å°”", "æ¸©å“¥å", "æ¥“è‘‰", "æ«å¶", "æ»‘é“å¢", "å¤šä¼¦å¤š"], "ğŸ‡¨ğŸ‡­": ["ç‘å£«", "è‹é»ä¸–", "Switzerland"], "ğŸ‡©ğŸ‡ª": ["DE", "German", "GERMAN", "å¾·å›½", "å¾·åœ‹", "æ³•å…°å…‹ç¦"], "ğŸ‡©ğŸ‡°": ["ä¸¹éº¦"], "ğŸ‡ªğŸ‡¸": ["ES", "è¥¿ç­ç‰™", "Spain"], "ğŸ‡ªğŸ‡º": ["EU", "æ¬§ç›Ÿ", "æ¬§ç½—å·´"], "ğŸ‡«ğŸ‡®": ["Finland", "èŠ¬å…°", "èµ«å°”è¾›åŸº"], "ğŸ‡«ğŸ‡·": ["FR", "France", "æ³•å›½", "æ³•åœ‹", "å·´é»"], "ğŸ‡¬ğŸ‡§": ["UK", "GB", "England", "United Kingdom", "è‹±å›½", "ä¼¦æ•¦", "è‹±"], "ğŸ‡²ğŸ‡´": ["MO", "Macao", "æ¾³é—¨", "CTM"], "ğŸ‡­ğŸ‡º": ["åŒˆç‰™åˆ©", "Hungary"], "ğŸ‡­ğŸ‡°": ["HK", "Hongkong", "Hong Kong", "é¦™æ¸¯", "æ·±æ¸¯", "æ²ªæ¸¯", "å‘¼æ¸¯", "HKT", "HKBN", "HGC", "WTT", "CMI", "ç©—æ¸¯", "äº¬æ¸¯", "æ¸¯"], "ğŸ‡®ğŸ‡©": ["Indonesia", "å°å°¼", "å°åº¦å°¼è¥¿äºš", "é›…åŠ è¾¾"], "ğŸ‡®ğŸ‡ª": ["Ireland", "çˆ±å°”å…°", "éƒ½æŸæ—"], "ğŸ‡®ğŸ‡³": ["India", "å°åº¦", "å­Ÿä¹°", "Mumbai"], "ğŸ‡°ğŸ‡µ": ["KP", "æœé²œ"], "ğŸ‡°ğŸ‡·": ["KR", "Korea", "KOR", "éŸ©å›½", "é¦–å°”", "éŸ©", "éŸ“"], "ğŸ‡±ğŸ‡»": ["Latvia", "Latvija", "æ‹‰è„±ç»´äºš"], "ğŸ‡²ğŸ‡½ï¸": ["MEX", "MX", "å¢¨è¥¿å“¥"], "ğŸ‡²ğŸ‡¾": ["MY", "Malaysia", "é©¬æ¥è¥¿äºš", "å‰éš†å¡"], "ğŸ‡³ğŸ‡±": ["NL", "Netherlands", "è·å…°", "è·è˜­", "å°¼å¾·è˜­", "é˜¿å§†æ–¯ç‰¹ä¸¹"], "ğŸ‡µğŸ‡­": ["PH", "Philippines", "è²å¾‹å®¾"], "ğŸ‡·ğŸ‡´": ["RO", "ç½—é©¬å°¼äºš"], "ğŸ‡·ğŸ‡º": ["RU", "Russia", "ä¿„ç½—æ–¯", "ä¿„ç¾…æ–¯", "ä¼¯åŠ›", "è«æ–¯ç§‘", "åœ£å½¼å¾—å ¡", "è¥¿ä¼¯åˆ©äºš", "æ–°è¥¿ä¼¯åˆ©äºš", "äº¬ä¿„", "æ­ä¿„"], "ğŸ‡¸ğŸ‡¦": ["æ²™ç‰¹", "è¿ªæ‹œ"], "ğŸ‡¸ğŸ‡ª": ["SE", "Sweden"], "ğŸ‡¸ğŸ‡¬": ["SG", "Singapore", "æ–°åŠ å¡", "ç‹®åŸ", "æ²ªæ–°", "äº¬æ–°", "æ³‰æ–°", "ç©—æ–°", "æ·±æ–°", "æ­æ–°", "å¹¿æ–°"], "ğŸ‡¹ğŸ‡­": ["TH", "Thailand", "æ³°å›½", "æ³°åœ‹", "æ›¼è°·"], "ğŸ‡¹ğŸ‡·": ["TR", "Turkey", "åœŸè€³å…¶", "ä¼Šæ–¯å¦å¸ƒå°”"], "ğŸ‡¹ğŸ‡¼": ["TW", "Taiwan", "å°æ¹¾", "å°åŒ—", "å°ä¸­", "æ–°åŒ—", "å½°åŒ–", "CHT", "å°", "HINET"], "ğŸ‡ºğŸ‡¸": ["US", "USA", "America", "United States", "ç¾å›½", "ç¾", "äº¬ç¾", "æ³¢ç‰¹å…°", "è¾¾æ‹‰æ–¯", "ä¿„å‹’å†ˆ", "å‡¤å‡°åŸ", "è´¹åˆ©è’™", "ç¡…è°·", "çŸ½è°·", "æ‹‰æ–¯ç»´åŠ æ–¯", "æ´›æ‰çŸ¶", "åœ£ä½•å¡", "åœ£å…‹æ‹‰æ‹‰", "è¥¿é›…å›¾", "èŠåŠ å“¥", "æ²ªç¾", "å“¥ä¼¦å¸ƒ", "çº½çº¦"], "ğŸ‡»ğŸ‡³": ["VN", "è¶Šå—", "èƒ¡å¿—æ˜å¸‚"], "ğŸ‡®ğŸ‡¹": ["Italy", "IT", "Nachash", "æ„å¤§åˆ©", "ç±³å…°", "ç¾©å¤§åˆ©"], "ğŸ‡¿ğŸ‡¦": ["South Africa", "å—é"], "ğŸ‡¦ğŸ‡ª": ["United Arab Emirates", "é˜¿è”é…‹"], "ğŸ‡¯ğŸ‡µ": ["JP", "Japan", "æ—¥", "æ—¥æœ¬", "ä¸œäº¬", "å¤§é˜ª", "åŸ¼ç‰", "æ²ªæ—¥", "ç©—æ—¥", "å·æ—¥", "ä¸­æ—¥", "æ³‰æ—¥", "æ­æ—¥", "æ·±æ—¥", "è¾½æ—¥", "å¹¿æ—¥"], "ğŸ‡¦ğŸ‡·": ["AR", "é˜¿æ ¹å»·"], "ğŸ‡³ğŸ‡´": ["Norway", "æŒªå¨", "NO"], "ğŸ‡¨ğŸ‡³": ["CN", "China", "å›å›½", "ä¸­å›½", "æ±Ÿè‹", "åŒ—äº¬", "ä¸Šæµ·", "å¹¿å·", "æ·±åœ³", "æ­å·", "å¾å·", "é’å²›", "å®æ³¢", "é•‡æ±Ÿ", "back"] }
            if (Pemoji == 1) {
                str1 = JSON.stringify(Lmoji)
                aa = JSON.parse(str1)
                var nname = get_emoji(aa, nname)
            } else if (Pemoji == 2) {
                str1 = JSON.stringify(Lmoji)
                bb = JSON.parse(str1.replace(/ğŸ‡¹ğŸ‡¼/g, " ğŸ‡¨ğŸ‡³"))
                var nname = get_emoji(bb, nname)
            } else if (Pemoji == -1) {
                nname = emoji_del(oname);
            }
            var nserver = hd + "tag=" + nname.replace(" ï¸", " ").trim()
            nlist.push(nserver)
        }
    }
    return nlist
}

//Surge2QX è½¬æ¢ä¸»å‡½æ•°
function Surge2QX(conf) {
    var QXlist = conf.split("\n").map(isSurge).filter(Boolean)
    var Nlist = []
    for (var i = 0; i < QXlist.length; i++) {
        var cnt = QXlist[i];
        if (cnt.split("=")[1].split(",")[0].indexOf("trojan") != -1) {
            Nlist.push(Strojan2QX(cnt))//surge 3çš„trojan
        } else if (cnt.split("=")[1].split(",")[0].indexOf("http") != -1) {
            Nlist.push(Shttp2QX(cnt)) //surge 3çš„http
        } else if (cnt.split("=")[1].split(",")[0].indexOf("vmess") != -1) {
            Nlist.push(SVmess2QX(cnt)) //surge 3çš„Vmess
        } else if (cnt.split("=")[1].split(",")[0].indexOf("ss") != -1) {
            Nlist.push(SSS2QX(cnt)) //surge 3çš„SS
        } else if (cnt.split("=")[1].split(",")[0].indexOf("custom") != -1) {
            Nlist.push(SCT2QX(cnt)) //surge2å†™æ³•
        }
    }
    return (Nlist)
}

// surge2 ä¸­çš„ SS ç±»å‹å†™æ³•(custom)
//ğŸ‡·ğŸ‡º ä¿„ç½—æ–¯ GIA = custom, ip, 152, aes-128-gcm, password123, https://xxx/download/SSEncrypt.module, obfs=tls, obfs-host=xxx.windows.com, udp-relay=true
function SCT2QX(content) {
    var cnt = content;
    var tag = "tag=" + cnt.split("=")[0].trim();
    var ipport = cnt.split(",")[1].trim() + ":" + cnt.split(",")[2].trim();
    var pmtd = "method=" + cnt.split(",")[3].trim();
    var pwd = "password=" + cnt.split(",")[4].trim();
    if (cnt.indexOf("obfs") != -1) {
        pobfs = "obfs=" + cnt.replace(/obfs-host/, "").split("obfs")[1].split(",")[0].split("=")[1]
    } else { pobfs = "" }
    var phost = cnt.indexOf("obfs-host") != -1 ? "obfs-host" + cnt.split("obfs-host")[1].split(",")[0].trim() : "";
    if (phost != "") {
        pobfs = pobfs + ", " + phost
    }
    var ptfo = paraCheck(cnt, "tfo") == "true" ? "fast-open=true" : "fast-open=false";
    var pudp = paraCheck(cnt, "udp") == "true" ? "udp-relay=true" : "udp-relay=false";
    var nserver = pobfs != "" ? "shadowsocks= " + [ipport, pmtd, pwd, pobfs, ptfo, pudp, tag].join(", ") : "shadowsocks= " + [ipport, pmtd, pwd, ptfo, pudp, tag].join(", ");
    return nserver
}


// surge ä¸­çš„ SS ç±»å‹
function SSS2QX(content) {
    var cnt = content;
    var tag = "tag=" + cnt.split("=")[0].trim();
    var ipport = cnt.split(",")[1].trim() + ":" + cnt.split(",")[2].trim();
    var pmtd = "method=" + cnt.split("encrypt-method")[1].split(",")[0].split("=")[1];
    var pwd = "password=" + cnt.split("password")[1].split(",")[0].split("=")[1];
    if (cnt.indexOf("obfs") != -1) {
        pobfs = "obfs=" + cnt.replace(/obfs-host/, "").split("obfs")[1].split(",")[0].split("=")[1]
    } else { pobfs = "" }
    var phost = cnt.indexOf("obfs-host") != -1 ? "obfs-host" + cnt.split("obfs-host")[1].split(",")[0].trim() : "";
    if (phost != "") {
        pobfs = pobfs + ", " + phost
    }
    var ptfo = paraCheck(cnt, "tfo") == "true" ? "fast-open=true" : "fast-open=false";
    var pudp = paraCheck(cnt, "udp") == "true" ? "udp-relay=true" : "udp-relay=false";
    var nserver = pobfs != "" ? "shadowsocks= " + [ipport, pmtd, pwd, pobfs, ptfo, pudp, tag].join(", ") : "shadowsocks= " + [ipport, pmtd, pwd, ptfo, pudp, tag].join(", ");
    return nserver
}

// surge ä¸­çš„ Vmess ç±»å‹
function SVmess2QX(content) {
    var cnt = content;
    var tag = "tag=" + cnt.split("=")[0].trim();
    var ipport = cnt.split(",")[1].trim() + ":" + cnt.split(",")[2].trim();
    var puname = cnt.indexOf("username") != -1 ? "password=" + cnt.split("username")[1].split(",")[0].split("=")[1].trim() : "";
    var pmtd = "method=aes-128-gcm";
    var ptls13 = paraCheck(cnt, "tls13") == "true" ? "tls13=true" : "tls13=false";
    var pverify = paraCheck(cnt, "skip-cert-verify") == "true" ? "tls-verification=false" : "tls-verification=true";
    if (paraCheck(cnt.replace(/tls13/, ""), "tls") == "true" && paraCheck(cnt.replace(/ws-header/, ""), "ws") == "true") {
        pobfs = "obfs=wss" + ", " + ptls13 + ", " + pverify
    } else if (paraCheck(cnt.replace(/ws-header/, ""), "ws") == "true") {
        pobfs = "obfs=ws"
    } else if (paraCheck(cnt.replace(/tls13/, ""), "tls") != "false") {
        pobfs = "obfs=over-tls" + ", " + ptls13 + ", " + pverify
    } else if (paraCheck(cnt.replace(/ws-header/, ""), "ws") == "false") {
        pobfs = ""
    }
    var puri = paraCheck(cnt, "ws-path") != "false" ? "obfs-uri=" + cnt.split("ws-path")[1].split(",")[0].split("=")[1].trim() : "obfs-uri=/"
    var phost = cnt.indexOf("ws-headers") != -1 ? "obfs-host=" + cnt.split("ws-headers")[1].split(",")[0].split("=")[1].split("Host:")[1].trim() : "";
    if (pobfs.indexOf("ws" || "wss") != -1) {
        if (phost != "") {
            pobfs = pobfs + ", " + puri + ", " + phost
        } else { pobfs = pobfs + ", " + puri }
    }
    var ptfo = paraCheck(cnt, "tfo") == "true" ? "fast-open=true" : "fast-open=false";
    var nserver = pobfs != "" ? "vmess= " + [ipport, puname, pmtd, pobfs, ptfo, tag].join(", ") : "vmess= " + [ipport, puname, pmtd, ptfo, tag].join(", ");
    return nserver
}

// ç”¨äºè¿‡æ»¤éèŠ‚ç‚¹éƒ¨åˆ†ï¼ˆæ¯”å¦‚æ•´ä»½é…ç½®ä¸­å…¶å®ƒå†…å®¹ï¼‰
function isSurge(content) {
    if (content.indexOf("=") != -1) {
        cnt = content.split("=")[1].split(",")[0].trim()
        if (cnt == "http" || cnt == "ss" || cnt == "trojan" || cnt == "vmess" || cnt == "custom") {
            return content
        }
    }
}
// ç”¨äºå‚æ•°æ£€æŸ¥
function paraCheck(content, para) {
    if (content.indexOf(para) == -1) {
        return "false"
    } else {
        return content.split(para)[1].split(",")[0].split("=")[1].trim()
    }
}
//surgeä¸­ trojan ç±»å‹è½¬æ¢
function Strojan2QX(content) {
    var cnt = content;
    var tag = "tag=" + cnt.split("=")[0].trim();
    var ipport = cnt.split(",")[1].trim() + ":" + cnt.split(",")[2].trim();
    var pwd = "password=" + cnt.split("password")[1].split(",")[0].split("=")[1].trim();
    var ptls = "over-tls=true";
    var ptfo = paraCheck(cnt, "tfo") == "true" ? "fast-open=true" : "fast-open=false";
    var pverify = paraCheck(cnt, "skip-cert-verify") == "true" ? "tls-verification=false" : "tls-verification=true";
    var ptls13 = paraCheck(cnt, "tls13") == "true" ? "tls13=true" : "tls13=false";
    var nserver = "trojan= " + [ipport, pwd, ptls, ptfo, ptls13, pverify, tag].join(", ");
    return nserver
}
// surge ä¸­çš„ http ç±»å‹
function Shttp2QX(content) {
    var cnt = content;
    var tag = "tag=" + cnt.split("=")[0].trim();
    var ipport = cnt.split(",")[1].trim() + ":" + cnt.split(",")[2].trim();
    var puname = cnt.indexOf("username") != -1 ? "username=" + cnt.split("username")[1].split(",")[0].split("=")[1].trim() : "";
    var pwd = cnt.indexOf("password") != -1 ? "password=" + cnt.split("password")[1].split(",")[0].split("=")[1].trim() : "";
    var ptls = cnt.split("=")[1].split(",")[0].trim() == "https" ? "over-tls=true" : "over-tls=false";
    var ptfo = paraCheck(cnt, "tfo") == "true" ? "fast-open=true" : "fast-open=false";
    if (ptls == "over-tls=true") {
        var pverify = paraCheck(cnt, "skip-cert-verify") == "true" ? "tls-verification=false" : "tls-verification=true";
        var ptls13 = paraCheck(cnt, "tls13") == "true" ? "tls13=true" : "tls13=false";
        ptls = ptls + ", " + pverify + ", " + ptls13
    }
    var nserver = puname != "" ? "http= " + [ipport, puname, pwd, ptls, ptfo, tag].join(", ") : "http= " + [ipport, ptls, ptfo, tag].join(", ");
    return nserver
}

function Loon2QX(cnt) {
    var type = cnt.split("=")[1].split(",")[0].trim()
    var node = ""
    if (type == "Shadowsocks") { //ss ç±»å‹
        node = LoonSS2QX(cnt)
    } else if (type == "ShadowsocksR") { //ssr ç±»å‹
        node = LoonSSR2QX(cnt)
    }
    return node
}
//Loon çš„ ss éƒ¨åˆ†
function LoonSS2QX(cnt) {
    var node = "shadowsocks="
    var ip = [cnt.split(",")[1].trim(), cnt.split(",")[2].trim()].join(":")
    var mtd = "method=" + cnt.split(",")[3].trim()
    var pwd = "password=" + cnt.split(",")[4].trim().split("\"")[1]
    var obfs = cnt.split(",").length == 7 ? ", " + ["obfs=" + cnt.split(",")[5].trim(), "obfs-host=" + cnt.split(",")[6].trim()].join(",") : ""
    var tag = ", tag=" + cnt.split("=")[0].trim()
    node = node + [ip, mtd, pwd].join(", ") + obfs + tag
    return node
}

//Loon çš„ ssr éƒ¨åˆ†
//# SSR æ ¼å¼ï¼šåç§°=åè®®ç±»å‹,åœ°å€,ç«¯å£,åŠ å¯†æ–¹å¼,å¯†ç ,åè®®ç±»å‹,{åè®®å‚æ•°},æ··æ·†ç±»å‹,{æ··æ·†å‚æ•°}
//3 = ShadowsocksR, 1.2.3.4, 443, aes-256-cfb,"password",auth_aes128_md5,{},tls1.2_ticket_auth,{}
function LoonSSR2QX(cnt) {
    var node = "shadowsocks="
    var ip = [cnt.split(",")[1].trim(), cnt.split(",")[2].trim()].join(":")
    var mtd = "method=" + cnt.split(",")[3].trim()
    var pwd = "password=" + cnt.split(",")[4].trim().split("\"")[1]
    var ssrp = "ssr-protocol=" + cnt.split(",")[5].trim()
    var ssrpara = "ssr-protocol-param=" + cnt.split(",")[6].replace(/\{|\}/g, "").trim()
    var obfs = "obfs=" + cnt.split(",")[7].trim()
    var obfshost = "obfs-host=" + cnt.split(",")[8].replace(/\{|\}/g, "").trim()
    var tag = ", tag=" + cnt.split("=")[0].trim()
    node = node + [ip, mtd, pwd, ssrp, ssrpara, obfs, obfshost].join(", ") + tag
    return node
}

//æ¯”è¾ƒå®Œç¾çš„ä¸€æ¬¾ base64 encode/decode å·¥å…·
/*
 *  base64.js: https://github.com/dankogai/js-base64#readme
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 */
//base64 å®Œæ¯•
function Base64Code() {
    // constants
    var b64chars
        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    var b64tab = function (bin) {
        var t = {};
        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
        return t;
    }(b64chars);
    var fromCharCode = String.fromCharCode;
    // encoder stuff
    var cb_utob = function (c) {
        if (c.length < 2) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c
                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))
                    + fromCharCode(0x80 | (cc & 0x3f)))
                    : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))
                        + fromCharCode(0x80 | ((cc >>> 6) & 0x3f))
                        + fromCharCode(0x80 | (cc & 0x3f)));
        } else {
            var cc = 0x10000
                + (c.charCodeAt(0) - 0xD800) * 0x400
                + (c.charCodeAt(1) - 0xDC00);
            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))
                + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))
                + fromCharCode(0x80 | ((cc >>> 6) & 0x3f))
                + fromCharCode(0x80 | (cc & 0x3f)));
        }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    var utob = function (u) {
        return u.replace(re_utob, cb_utob);
    };
    var cb_encode = function (ccc) {
        var padlen = [0, 2, 1][ccc.length % 3],
            ord = ccc.charCodeAt(0) << 16
                | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
                | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
            chars = [
                b64chars.charAt(ord >>> 18),
                b64chars.charAt((ord >>> 12) & 63),
                padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
                padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
            ];
        return chars.join('');
    };
    var btoa = function (b) {
        return b.replace(/[\s\S]{1,3}/g, cb_encode);
    };
    // var _encode = function(u) {
    // 	var isUint8Array = Object.prototype.toString.call(u) === '[object Uint8Array]';
    // 	return isUint8Array ? u.toString('base64')
    // 		: btoa(utob(String(u)));
    // }
    this.encode = function (u) {
        var isUint8Array = Object.prototype.toString.call(u) === '[object Uint8Array]';
        return isUint8Array ? u.toString('base64')
            : btoa(utob(String(u)));
    }
    var uriencode = function (u, urisafe) {
        return !urisafe
            ? _encode(u)
            : _encode(String(u)).replace(/[+\/]/g, function (m0) {
                return m0 == '+' ? '-' : '_';
            }).replace(/=/g, '');
    };
    var encodeURI = function (u) { return uriencode(u, true) };
    // decoder stuff
    var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
    var cb_btou = function (cccc) {
        switch (cccc.length) {
            case 4:
                var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                    | ((0x3f & cccc.charCodeAt(1)) << 12)
                    | ((0x3f & cccc.charCodeAt(2)) << 6)
                    | (0x3f & cccc.charCodeAt(3)),
                    offset = cp - 0x10000;
                return (fromCharCode((offset >>> 10) + 0xD800)
                    + fromCharCode((offset & 0x3FF) + 0xDC00));
            case 3:
                return fromCharCode(
                    ((0x0f & cccc.charCodeAt(0)) << 12)
                    | ((0x3f & cccc.charCodeAt(1)) << 6)
                    | (0x3f & cccc.charCodeAt(2))
                );
            default:
                return fromCharCode(
                    ((0x1f & cccc.charCodeAt(0)) << 6)
                    | (0x3f & cccc.charCodeAt(1))
                );
        }
    };
    var btou = function (b) {
        return b.replace(re_btou, cb_btou);
    };
    var cb_decode = function (cccc) {
        var len = cccc.length,
            padlen = len % 4,
            n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)
                | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)
                | (len > 2 ? b64tab[cccc.charAt(2)] << 6 : 0)
                | (len > 3 ? b64tab[cccc.charAt(3)] : 0),
            chars = [
                fromCharCode(n >>> 16),
                fromCharCode((n >>> 8) & 0xff),
                fromCharCode(n & 0xff)
            ];
        chars.length -= [0, 0, 2, 1][padlen];
        return chars.join('');
    };
    var _atob = function (a) {
        return a.replace(/\S{1,4}/g, cb_decode);
    };
    var atob = function (a) {
        return _atob(String(a).replace(/[^A-Za-z0-9\+\/]/g, ''));
    };
    // var _decode = buffer ?
    // 	buffer.from && Uint8Array && buffer.from !== Uint8Array.from
    // 	? function(a) {
    // 		return (a.constructor === buffer.constructor
    // 				? a : buffer.from(a, 'base64')).toString();
    // 	}
    // 	: function(a) {
    // 		return (a.constructor === buffer.constructor
    // 				? a : new buffer(a, 'base64')).toString();
    // 	}
    // 	: function(a) { return btou(_atob(a)) };
    var _decode = function (u) {
        return btou(_atob(u))
    }
    this.decode = function (a) {
        return _decode(
            String(a).replace(/[-_]/g, function (m0) { return m0 == '-' ? '+' : '/' })
                .replace(/[^A-Za-z0-9\+\/]/g, '')
        ).replace(/&gt;/g, ">").replace(/&lt;/g, "<");
    };
}


/***********************************************************************************************/
function Tools() {
    const filter = (src, ...regex) => {
        const initial = [...Array(src.length).keys()].map(() => false);
        return regex.reduce((a, expr) => OR(a, src.map(item => expr.test(item))), initial)
    }

    const rename = {
        replace: (src, old, now) => {
            return src.map(item => item.replace(old, now));
        },

        delete: (src, ...args) => {
            return src.map(item => args.reduce((now, expr) => now.replace(expr, ''), item));
        },

        trim: (src) => {
            return src.map(item => item.trim().replace(/[^\S\r\n]{2,}/g, ' '));
        }
    }

    const getNodeInfo = servers => {
        const nodes = {
            names: servers.map(s => s.split("tag=")[1]),
            types: servers.map(s => {
                const type = s.match(/^(vmess|trojan|shadowsocks|http)=/);
                return type ? type[1] : 'unknown';
            })
        };
        return nodes;
    }


    return {
        filter, rename, getNodeInfo
    }
}

function AND(...args) {
    return args.reduce((a, b) => a.map((c, i) => b[i] && c));
}

function OR(...args) {
    return args.reduce((a, b) => a.map((c, i) => b[i] || c))
}

function NOT(array) {
    return array.map(c => !c);
}